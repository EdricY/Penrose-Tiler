/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/camera.js":
/*!***********************!*\
  !*** ./src/camera.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Camera; });\n/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals */ \"./src/globals.js\");\n\r\n\r\nclass Camera {\r\n  constructor() {\r\n    this.x = 0;\r\n    this.y = 0;\r\n    this.scale = 1;\r\n  }\r\n\r\n  moveCtx(ctx) {\r\n    ctx.scale(this.scale, this.scale);\r\n    ctx.translate(-Math.round(this.x), -Math.round(this.y));\r\n  }\r\n\r\n  zoomAt(x, y, amt=.1) {\r\n    if (this.scale + amt <= .2) return;\r\n    let ow = _globals__WEBPACK_IMPORTED_MODULE_0__[\"W\"] / this.scale;\r\n    let oh = _globals__WEBPACK_IMPORTED_MODULE_0__[\"H\"] / this.scale;\r\n\r\n    let dx = x - this.x;\r\n    let dy = y - this.y;\r\n\r\n    this.scale += amt;\r\n    \r\n    let nw = _globals__WEBPACK_IMPORTED_MODULE_0__[\"W\"] / this.scale;\r\n    let nh = _globals__WEBPACK_IMPORTED_MODULE_0__[\"H\"] / this.scale;\r\n\r\n    let px = dx / nw;\r\n    let py = dy / nh;\r\n\r\n    let dw = ow - nw;\r\n    let dh = oh - nh;\r\n\r\n    this.x += dw * px\r\n    this.y += dh * py;\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/camera.js?");

/***/ }),

/***/ "./src/cursor.js":
/*!***********************!*\
  !*** ./src/cursor.js ***!
  \***********************/
/*! exports provided: cursor, chosenShape, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cursor\", function() { return cursor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"chosenShape\", function() { return chosenShape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return drawCursor; });\n/* harmony import */ var _shapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shapes.js */ \"./src/shapes.js\");\n/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./globals */ \"./src/globals.js\");\n/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./main */ \"./src/main.js\");\n\r\n\r\n\r\n\r\nconst cursorCtx = document.createElement(\"canvas\").getContext(\"2d\");\r\ncursorCtx.canvas.width = _globals__WEBPACK_IMPORTED_MODULE_1__[\"W\"];\r\ncursorCtx.canvas.height = _globals__WEBPACK_IMPORTED_MODULE_1__[\"H\"];\r\n\r\nconst cursor = {x: 0, y: 0};\r\nlet chosenShape = _globals__WEBPACK_IMPORTED_MODULE_1__[\"Shapes\"].KITE;\r\n\r\nfunction drawCursor(ctx) {\r\n  cursorCtx.clearRect(0, 0, _globals__WEBPACK_IMPORTED_MODULE_1__[\"W\"], _globals__WEBPACK_IMPORTED_MODULE_1__[\"H\"]);\r\n\r\n  ctx.drawImage(cursorCtx.canvas, 0, 0);\r\n}\r\n\r\nconst canvasClientRatio = 1;\r\n\r\ncanvas.addEventListener(\"mousemove\", e => {\r\n  cursor.x = e.offsetX / _globals__WEBPACK_IMPORTED_MODULE_1__[\"camera\"].scale  + _globals__WEBPACK_IMPORTED_MODULE_1__[\"camera\"].x;\r\n  cursor.y = e.offsetY / _globals__WEBPACK_IMPORTED_MODULE_1__[\"camera\"].scale  + _globals__WEBPACK_IMPORTED_MODULE_1__[\"camera\"].y;\r\n});\r\n\r\n\r\nwindow.addEventListener(\"keypress\", e => {\r\n  if (e.key == \"1\")      chosenShape = _globals__WEBPACK_IMPORTED_MODULE_1__[\"Shapes\"].KITE;\r\n  else if (e.key == \"2\") chosenShape = _globals__WEBPACK_IMPORTED_MODULE_1__[\"Shapes\"].DART;\r\n});\r\n\r\n\n\n//# sourceURL=webpack:///./src/cursor.js?");

/***/ }),

/***/ "./src/floor.js":
/*!**********************!*\
  !*** ./src/floor.js ***!
  \**********************/
/*! exports provided: floorShapes, drawFloor, addToFloor, removeFromFloor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"floorShapes\", function() { return floorShapes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"drawFloor\", function() { return drawFloor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addToFloor\", function() { return addToFloor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeFromFloor\", function() { return removeFromFloor; });\n/* harmony import */ var _shapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shapes.js */ \"./src/shapes.js\");\n/* harmony import */ var _cursor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cursor.js */ \"./src/cursor.js\");\n/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./globals */ \"./src/globals.js\");\n\r\n\r\n\r\n\r\n\r\nconst tileCtx = document.createElement(\"canvas\").getContext(\"2d\");\r\ntileCtx.canvas.width = _globals__WEBPACK_IMPORTED_MODULE_2__[\"W\"];\r\ntileCtx.canvas.height = _globals__WEBPACK_IMPORTED_MODULE_2__[\"H\"];\r\n\r\nconst floorShapes = []; //TODO: use kd tree\r\n\r\nfunction drawFloor(ctx) {\r\n  // ctx.drawImage(tileCtx.canvas, 0, 0);\r\n  for (let i = 0; i < floorShapes.length; i++) {\r\n    const shape = floorShapes[i];\r\n    shape.draw(ctx)\r\n  }\r\n}\r\n\r\nfunction addToFloor(shape) {\r\n  floorShapes.push(shape);\r\n  // shape.draw(tileCtx)\r\n}\r\n\r\nfunction removeFromFloor(shape) {\r\n  let index = floorShapes.indexOf(shape);  //TODO: use nonlinear remove\r\n  if (index > -1) {\r\n    floorShapes.splice(index, 1);\r\n  }\r\n\r\n  //redraw\r\n  // tileCtx.clearRect(0, 0, W, H);\r\n  // for (let shape of floorShapes) {\r\n  //   shape.draw(tileCtx)\r\n  // }\r\n}\r\n\r\n\n\n//# sourceURL=webpack:///./src/floor.js?");

/***/ }),

/***/ "./src/globals.js":
/*!************************!*\
  !*** ./src/globals.js ***!
  \************************/
/*! exports provided: W, H, PHI, SIN36, COS36, PI, TAU, Shapes, canvas, camera, dist, near, lerp, radians2Degrees, degrees2Radians, posMod, orientation, intersects, tree */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"W\", function() { return W; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"H\", function() { return H; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PHI\", function() { return PHI; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SIN36\", function() { return SIN36; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COS36\", function() { return COS36; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PI\", function() { return PI; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TAU\", function() { return TAU; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Shapes\", function() { return Shapes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"canvas\", function() { return canvas; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"camera\", function() { return camera; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dist\", function() { return dist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"near\", function() { return near; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lerp\", function() { return lerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"radians2Degrees\", function() { return radians2Degrees; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"degrees2Radians\", function() { return degrees2Radians; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"posMod\", function() { return posMod; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"orientation\", function() { return orientation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intersects\", function() { return intersects; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tree\", function() { return tree; });\n/* harmony import */ var _kdTree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./kdTree */ \"./src/kdTree.js\");\n/* harmony import */ var _kdTree__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_kdTree__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _camera_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./camera.js */ \"./src/camera.js\");\n\r\n\r\n\r\nconst W = 600;\r\nconst H = 600;\r\n\r\nconst PHI = 1.618033988749895;\r\nconst SIN36 = 0.5877852522924731;\r\nconst COS36 = 0.8090169943749474;\r\nconst PI = Math.PI;\r\nconst TAU = PI * 2;\r\n\r\nconst Shapes = { KITE: 0, DART: 1 };\r\n\r\nconst canvas = document.getElementById(\"canvas\");\r\nconst camera = new _camera_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\r\n\r\n\r\nfunction dist(a, b) {\r\n  if (a == null || b == null) return Infinity;\r\n  const dx = a.x - b.x;\r\n  const dy = a.y - b.y;\r\n  return dx*dx + dy*dy;\r\n}\r\n\r\nfunction near(a, b) {\r\n  if (a == b) return true;\r\n  return dist(a, b) < 1;\r\n}\r\n\r\n\r\nfunction lerp(a, b, frac) { return (a * frac) + (b * (1-frac)) }\r\n\r\nfunction radians2Degrees(rad) { return rad * (180/PI) }\r\nfunction degrees2Radians(deg) { return deg * (PI/180) }\r\n\r\nfunction posMod(x, n) {\r\n  while (x < 0) x += n;\r\n  return x % n\r\n}\r\n\r\nfunction orientation(p1, p2, p3) {\r\n  let dx1 = p2.x - p1.x;\r\n  let dy1 = p2.y - p1.y;\r\n  let dx2 = p3.x - p2.x;\r\n  let dy2 = p3.y - p2.y;\r\n  let dx3 = p3.x - p1.x;\r\n  let dy3 = p3.y - p1.y;\r\n  if (Math.abs(dx2) + Math.abs(dy2) < 1) return 0;\r\n  if (Math.abs(dx3) + Math.abs(dy3) < 1) return 0;\r\n\r\n  let val = (dy1) * (dx2) - (dx1) * (dy2);\r\n  if (Math.abs(val) < 1) return 0;\r\n  return val; //0 if colinear, + if cw, - if ccw\r\n}\r\n\r\nfunction intersects(lineSeg, halfedge)\r\n{\r\n  if (lineSeg.theta - halfedge.theta % 180 == 0) return false;\r\n  let o1 = orientation(lineSeg.pt1, lineSeg.pt2, halfedge.nextPt);\r\n  if (o1 == 0) return false;\r\n  let o2 = orientation(lineSeg.pt1, lineSeg.pt2, halfedge.fromPt);\r\n  if (o2 == 0) return false;\r\n  if (Math.sign(o1) == Math.sign(o2)) return false;\r\n  let o3 = orientation(halfedge.nextPt, halfedge.fromPt, lineSeg.pt1);\r\n  if (o3 == 0) return false;\r\n  let o4 = orientation(halfedge.nextPt, halfedge.fromPt, lineSeg.pt2);\r\n  if (o4 == 0) return false;\r\n  if (Math.sign(o3) == Math.sign(o4)) return false;\r\n\r\n  return true;\r\n} \r\n\r\n\r\nlet tree = new _kdTree__WEBPACK_IMPORTED_MODULE_0__[\"kdTree\"]([], dist, [\"x\", \"y\"]);\r\n// halfedges with null face\r\nwindow.tree = tree;\r\n\n\n//# sourceURL=webpack:///./src/globals.js?");

/***/ }),

/***/ "./src/halfedge.js":
/*!*************************!*\
  !*** ./src/halfedge.js ***!
  \*************************/
/*! exports provided: Halfedge, Point */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Halfedge\", function() { return Halfedge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Point\", function() { return Point; });\n/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals */ \"./src/globals.js\");\n\r\n\r\nclass Halfedge {\r\n  constructor(face, fromPt, nextPt, alpha, blue, theta) {\r\n    this.face = face;\r\n    this.nextPt = nextPt;\r\n    this.fromPt = fromPt;\r\n    \r\n    this.blue = blue;\r\n    this.alpha = alpha;\r\n\r\n    this.theta = Object(_globals__WEBPACK_IMPORTED_MODULE_0__[\"posMod\"])(theta, 360);\r\n\r\n    // this.next = next;\r\n    // this.prev = prev;\r\n    // this.opp = opp;\r\n\r\n    this.x = Object(_globals__WEBPACK_IMPORTED_MODULE_0__[\"lerp\"])(fromPt.x, nextPt.x, .5);\r\n    this.y = Object(_globals__WEBPACK_IMPORTED_MODULE_0__[\"lerp\"])(fromPt.y, nextPt.y, .5);\r\n  }\r\n\r\n  chain(next) {\r\n    this.next = next;\r\n    next.prev = this;\r\n  }\r\n\r\n  pair(opp) {\r\n    this.opp = opp;\r\n    opp.opp = this;\r\n  }\r\n\r\n  matches(that) {\r\n    if (this.blue != that.blue) return false;\r\n    if (this.alpha != that.alpha) return false;\r\n    if (this.theta != that.theta) return false;\r\n    if (!Object(_globals__WEBPACK_IMPORTED_MODULE_0__[\"near\"])(this, that)) return false;\r\n    return true;\r\n  }\r\n}\r\n\r\nclass Point {\r\n  constructor(x, y) {\r\n    if (x == null) x = 0;\r\n    if (y == null) y = 0;\r\n    this.vals = [x, y];\r\n\r\n    // this.halfedge = he;\r\n  }\r\n\r\n  get x() { return this.vals[0]; }\r\n  get y() { return this.vals[1]; }\r\n\r\n  draw(ctx, r=2, color=\"black\") {\r\n    ctx.fillStyle = color;\r\n    ctx.beginPath();\r\n    ctx.arc(this.x, this.y, r, 0, _globals__WEBPACK_IMPORTED_MODULE_0__[\"TAU\"]);\r\n    ctx.fill();\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/halfedge.js?");

/***/ }),

/***/ "./src/kdTree.js":
/*!***********************!*\
  !*** ./src/kdTree.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\r\n * k-d Tree JavaScript - V 1.01\r\n *\r\n * https://github.com/ubilabs/kd-tree-javascript\r\n *\r\n * @author Mircea Pricop <pricop@ubilabs.net>, 2012\r\n * @author Martin Kleppe <kleppe@ubilabs.net>, 2012\r\n * @author Ubilabs http://ubilabs.net, 2012\r\n * @license MIT License <http://www.opensource.org/licenses/mit-license.php>\r\n */\r\n\r\n(function (root, factory) {\r\n  if (true) {\r\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n  } else {}\r\n}(this, function (exports) {\r\nfunction Node(obj, dimension, parent) {\r\n  this.obj = obj;\r\n  this.left = null;\r\n  this.right = null;\r\n  this.parent = parent;\r\n  this.dimension = dimension;\r\n}\r\n\r\nfunction kdTree(points, metric, dimensions) {\r\n\r\n  var self = this;\r\n\r\n  function buildTree(points, depth, parent) {\r\n    var dim = depth % dimensions.length,\r\n      median,\r\n      node;\r\n\r\n    if (points.length === 0) {\r\n      return null;\r\n    }\r\n    if (points.length === 1) {\r\n      return new Node(points[0], dim, parent);\r\n    }\r\n\r\n    points.sort(function (a, b) {\r\n      return a[dimensions[dim]] - b[dimensions[dim]];\r\n    });\r\n\r\n    median = Math.floor(points.length / 2);\r\n    node = new Node(points[median], dim, parent);\r\n    node.left = buildTree(points.slice(0, median), depth + 1, node);\r\n    node.right = buildTree(points.slice(median + 1), depth + 1, node);\r\n\r\n    return node;\r\n  }\r\n\r\n  // Reloads a serialized tree\r\n  function loadTree (data) {\r\n    // Just need to restore the `parent` parameter\r\n    self.root = data;\r\n\r\n    function restoreParent (root) {\r\n      if (root.left) {\r\n        root.left.parent = root;\r\n        restoreParent(root.left);\r\n      }\r\n\r\n      if (root.right) {\r\n        root.right.parent = root;\r\n        restoreParent(root.right);\r\n      }\r\n    }\r\n\r\n    restoreParent(self.root);\r\n  }\r\n\r\n  // If points is not an array, assume we're loading a pre-built tree\r\n  if (!Array.isArray(points)) loadTree(points, metric, dimensions);\r\n  else this.root = buildTree(points, 0, null);\r\n\r\n  // Convert to a JSON serializable structure; this just requires removing\r\n  // the `parent` property\r\n  this.toJSON = function (src) {\r\n    if (!src) src = this.root;\r\n    var dest = new Node(src.obj, src.dimension, null);\r\n    if (src.left) dest.left = self.toJSON(src.left);\r\n    if (src.right) dest.right = self.toJSON(src.right);\r\n    return dest;\r\n  };\r\n\r\n  this.insert = function (point) {\r\n    function innerSearch(node, parent) {\r\n\r\n      if (node === null) {\r\n        return parent;\r\n      }\r\n\r\n      var dimension = dimensions[node.dimension];\r\n      if (point[dimension] < node.obj[dimension]) {\r\n        return innerSearch(node.left, node);\r\n      } else {\r\n        return innerSearch(node.right, node);\r\n      }\r\n    }\r\n\r\n    var insertPosition = innerSearch(this.root, null),\r\n      newNode,\r\n      dimension;\r\n\r\n    if (insertPosition === null) {\r\n      this.root = new Node(point, 0, null);\r\n      return;\r\n    }\r\n\r\n    newNode = new Node(point, (insertPosition.dimension + 1) % dimensions.length, insertPosition);\r\n    dimension = dimensions[insertPosition.dimension];\r\n\r\n    if (point[dimension] < insertPosition.obj[dimension]) {\r\n      insertPosition.left = newNode;\r\n    } else {\r\n      insertPosition.right = newNode;\r\n    }\r\n  };\r\n\r\n  this.empty = function() { return this.root == null }\r\n  this.isSizeOne = function() { return this.root.left == null && this.root.right == null }\r\n\r\n  this.remove = function (point) {\r\n    var node;\r\n\r\n    function nodeSearch(node) {\r\n      if (node === null) {\r\n        return null;\r\n      }\r\n\r\n      if (node.obj === point) {\r\n        return node;\r\n      }\r\n\r\n      var dimension = dimensions[node.dimension];\r\n\r\n      if (point[dimension] < node.obj[dimension]) {\r\n        return nodeSearch(node.left, node);\r\n      } else {\r\n        return nodeSearch(node.right, node);\r\n      }\r\n    }\r\n\r\n    function removeNode(node) {\r\n      var nextNode,\r\n        nextObj,\r\n        pDimension;\r\n\r\n      function findMin(node, dim) {\r\n        var dimension,\r\n          own,\r\n          left,\r\n          right,\r\n          min;\r\n\r\n        if (node === null) {\r\n          return null;\r\n        }\r\n\r\n        dimension = dimensions[dim];\r\n\r\n        if (node.dimension === dim) {\r\n          if (node.left !== null) {\r\n            return findMin(node.left, dim);\r\n          }\r\n          return node;\r\n        }\r\n\r\n        own = node.obj[dimension];\r\n        left = findMin(node.left, dim);\r\n        right = findMin(node.right, dim);\r\n        min = node;\r\n\r\n        if (left !== null && left.obj[dimension] < own) {\r\n          min = left;\r\n        }\r\n        if (right !== null && right.obj[dimension] < min.obj[dimension]) {\r\n          min = right;\r\n        }\r\n        return min;\r\n      }\r\n\r\n      if (node.left === null && node.right === null) {\r\n        if (node.parent === null) {\r\n          self.root = null;\r\n          return;\r\n        }\r\n\r\n        pDimension = dimensions[node.parent.dimension];\r\n\r\n        if (node.obj[pDimension] < node.parent.obj[pDimension]) {\r\n          node.parent.left = null;\r\n        } else {\r\n          node.parent.right = null;\r\n        }\r\n        return;\r\n      }\r\n\r\n      // If the right subtree is not empty, swap with the minimum element on the\r\n      // node's dimension. If it is empty, we swap the left and right subtrees and\r\n      // do the same.\r\n      if (node.right !== null) {\r\n        nextNode = findMin(node.right, node.dimension);\r\n        nextObj = nextNode.obj;\r\n        removeNode(nextNode);\r\n        node.obj = nextObj;\r\n      } else {\r\n        nextNode = findMin(node.left, node.dimension);\r\n        nextObj = nextNode.obj;\r\n        removeNode(nextNode);\r\n        node.right = node.left;\r\n        node.left = null;\r\n        node.obj = nextObj;\r\n      }\r\n\r\n    }\r\n\r\n    node = nodeSearch(self.root);\r\n\r\n    if (node === null) { return; }\r\n\r\n    removeNode(node);\r\n  };\r\n\r\n  this.nearest = function (point, maxNodes=1, maxDistance) {\r\n    var i,\r\n      result,\r\n      bestNodes;\r\n\r\n    bestNodes = new BinaryHeap(\r\n      function (e) { return -e[1]; }\r\n    );\r\n\r\n    function nearestSearch(node) {\r\n      var bestChild,\r\n        dimension = dimensions[node.dimension],\r\n        ownDistance = metric(point, node.obj),\r\n        linearPoint = {},\r\n        linearDistance,\r\n        otherChild,\r\n        i;\r\n\r\n      function saveNode(node, distance) {\r\n        bestNodes.push([node, distance]);\r\n        if (bestNodes.size() > maxNodes) {\r\n          bestNodes.pop();\r\n        }\r\n      }\r\n\r\n      for (i = 0; i < dimensions.length; i += 1) {\r\n        if (i === node.dimension) {\r\n          linearPoint[dimensions[i]] = point[dimensions[i]];\r\n        } else {\r\n          linearPoint[dimensions[i]] = node.obj[dimensions[i]];\r\n        }\r\n      }\r\n\r\n      linearDistance = metric(linearPoint, node.obj);\r\n\r\n      if (node.right === null && node.left === null) {\r\n        if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {\r\n          saveNode(node, ownDistance);\r\n        }\r\n        return;\r\n      }\r\n\r\n      if (node.right === null) {\r\n        bestChild = node.left;\r\n      } else if (node.left === null) {\r\n        bestChild = node.right;\r\n      } else {\r\n        if (point[dimension] < node.obj[dimension]) {\r\n          bestChild = node.left;\r\n        } else {\r\n          bestChild = node.right;\r\n        }\r\n      }\r\n\r\n      nearestSearch(bestChild);\r\n\r\n      if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {\r\n        saveNode(node, ownDistance);\r\n      }\r\n\r\n      if (bestNodes.size() < maxNodes || Math.abs(linearDistance) < bestNodes.peek()[1]) {\r\n        if (bestChild === node.left) {\r\n          otherChild = node.right;\r\n        } else {\r\n          otherChild = node.left;\r\n        }\r\n        if (otherChild !== null) {\r\n          nearestSearch(otherChild);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (maxDistance) {\r\n      for (i = 0; i < maxNodes; i += 1) {\r\n        bestNodes.push([null, maxDistance]);\r\n      }\r\n    }\r\n\r\n    if(self.root)\r\n      nearestSearch(self.root);\r\n\r\n    result = [];\r\n\r\n    for (i = 0; i < Math.min(maxNodes, bestNodes.content.length); i += 1) {\r\n      if (bestNodes.content[i][0]) {\r\n        result.push([bestNodes.content[i][0].obj, bestNodes.content[i][1]]);\r\n      }\r\n    }\r\n    return result;\r\n  };\r\n\r\n  this.balanceFactor = function () {\r\n    function height(node) {\r\n      if (node === null) {\r\n        return 0;\r\n      }\r\n      return Math.max(height(node.left), height(node.right)) + 1;\r\n    }\r\n\r\n    function count(node) {\r\n      if (node === null) {\r\n        return 0;\r\n      }\r\n      return count(node.left) + count(node.right) + 1;\r\n    }\r\n\r\n    return height(self.root) / (Math.log(count(self.root)) / Math.log(2));\r\n  };\r\n}\r\n\r\n// Binary heap implementation from:\r\n// http://eloquentjavascript.net/appendix2.html\r\n\r\nfunction BinaryHeap(scoreFunction){\r\n  this.content = [];\r\n  this.scoreFunction = scoreFunction;\r\n}\r\n\r\nBinaryHeap.prototype = {\r\n  push: function(element) {\r\n    // Add the new element to the end of the array.\r\n    this.content.push(element);\r\n    // Allow it to bubble up.\r\n    this.bubbleUp(this.content.length - 1);\r\n  },\r\n\r\n  pop: function() {\r\n    // Store the first element so we can return it later.\r\n    var result = this.content[0];\r\n    // Get the element at the end of the array.\r\n    var end = this.content.pop();\r\n    // If there are any elements left, put the end element at the\r\n    // start, and let it sink down.\r\n    if (this.content.length > 0) {\r\n      this.content[0] = end;\r\n      this.sinkDown(0);\r\n    }\r\n    return result;\r\n  },\r\n\r\n  peek: function() {\r\n    return this.content[0];\r\n  },\r\n\r\n  remove: function(node) {\r\n    var len = this.content.length;\r\n    // To remove a value, we must search through the array to find\r\n    // it.\r\n    for (var i = 0; i < len; i++) {\r\n      if (this.content[i] == node) {\r\n        // When it is found, the process seen in 'pop' is repeated\r\n        // to fill up the hole.\r\n        var end = this.content.pop();\r\n        if (i != len - 1) {\r\n          this.content[i] = end;\r\n          if (this.scoreFunction(end) < this.scoreFunction(node))\r\n            this.bubbleUp(i);\r\n          else\r\n            this.sinkDown(i);\r\n        }\r\n        return;\r\n      }\r\n    }\r\n    throw new Error(\"Node not found.\");\r\n  },\r\n\r\n  size: function() {\r\n    return this.content.length;\r\n  },\r\n\r\n  bubbleUp: function(n) {\r\n    // Fetch the element that has to be moved.\r\n    var element = this.content[n];\r\n    // When at 0, an element can not go up any further.\r\n    while (n > 0) {\r\n      // Compute the parent element's index, and fetch it.\r\n      var parentN = Math.floor((n + 1) / 2) - 1,\r\n          parent = this.content[parentN];\r\n      // Swap the elements if the parent is greater.\r\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\r\n        this.content[parentN] = element;\r\n        this.content[n] = parent;\r\n        // Update 'n' to continue at the new position.\r\n        n = parentN;\r\n      }\r\n      // Found a parent that is less, no need to move it further.\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  },\r\n\r\n  sinkDown: function(n) {\r\n    // Look up the target element and its score.\r\n    var length = this.content.length,\r\n        element = this.content[n],\r\n        elemScore = this.scoreFunction(element);\r\n\r\n    while(true) {\r\n      // Compute the indices of the child elements.\r\n      var child2N = (n + 1) * 2, child1N = child2N - 1;\r\n      // This is used to store the new position of the element,\r\n      // if any.\r\n      var swap = null;\r\n      // If the first child exists (is inside the array)...\r\n      if (child1N < length) {\r\n        // Look it up and compute its score.\r\n        var child1 = this.content[child1N],\r\n            child1Score = this.scoreFunction(child1);\r\n        // If the score is less than our element's, we need to swap.\r\n        if (child1Score < elemScore)\r\n          swap = child1N;\r\n      }\r\n      // Do the same checks for the other child.\r\n      if (child2N < length) {\r\n        var child2 = this.content[child2N],\r\n            child2Score = this.scoreFunction(child2);\r\n        if (child2Score < (swap == null ? elemScore : child1Score)){\r\n          swap = child2N;\r\n        }\r\n      }\r\n\r\n      // If the element needs to be moved, swap it, and continue.\r\n      if (swap != null) {\r\n        this.content[n] = this.content[swap];\r\n        this.content[swap] = element;\r\n        n = swap;\r\n      }\r\n      // Otherwise, we are done.\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nexports.kdTree = kdTree;\r\nexports.BinaryHeap = BinaryHeap;\r\n}));\n\n//# sourceURL=webpack:///./src/kdTree.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! exports provided: theta */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"theta\", function() { return theta; });\n/* harmony import */ var _cursor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cursor.js */ \"./src/cursor.js\");\n/* harmony import */ var _floor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./floor.js */ \"./src/floor.js\");\n/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./globals */ \"./src/globals.js\");\n/* harmony import */ var _halfedge_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./halfedge.js */ \"./src/halfedge.js\");\n/* harmony import */ var _shapes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shapes.js */ \"./src/shapes.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst visCtx = _globals__WEBPACK_IMPORTED_MODULE_2__[\"canvas\"].getContext(\"2d\");\r\nvisCtx.canvas.width = _globals__WEBPACK_IMPORTED_MODULE_2__[\"W\"];\r\nvisCtx.canvas.width = _globals__WEBPACK_IMPORTED_MODULE_2__[\"H\"];\r\n\r\nrequestAnimationFrame(tick);\r\n\r\nfunction drawPath(ctx) {\r\n  let ptr = origin;\r\n  ctx.beginPath();\r\n  ctx.moveTo(ptr.x, ptr.y);\r\n  ptr = ptr.next;\r\n  let i = 0;\r\n  while (ptr != origin && i < maxDepth) {\r\n    ctx.lineTo(ptr.x, ptr.y);\r\n    ptr = ptr.next;\r\n    i ++;\r\n  }\r\n  ctx.lineTo(ptr.x, ptr.y);\r\n  ctx.lineJoin = \"round\";\r\n  ctx.lineWidth = 5;\r\n  ctx.strokeStyle = \"aqua\";\r\n  ctx.stroke();\r\n  ctx.lineWidth = 2;\r\n}\r\n\r\nfunction drawCircle(pt, color) {\r\n  visCtx.beginPath();\r\n  visCtx.strokeStyle = color;\r\n  visCtx.arc(pt.x, pt.y, 10, 0, Math.PI * 2);\r\n  visCtx.stroke();\r\n  visCtx.closePath();\r\n}\r\n\r\nfunction tick() {\r\n  visCtx.clearRect(0, 0, _globals__WEBPACK_IMPORTED_MODULE_2__[\"W\"], _globals__WEBPACK_IMPORTED_MODULE_2__[\"H\"]);\r\n  visCtx.save();\r\n  _globals__WEBPACK_IMPORTED_MODULE_2__[\"camera\"].moveCtx(visCtx);\r\n  update();\r\n  Object(_floor_js__WEBPACK_IMPORTED_MODULE_1__[\"drawFloor\"])(visCtx);\r\n  // drawCursor(visCtx);\r\n\r\n  if (close1) {\r\n    if (!invalid) {\r\n      let shapeClass = _cursor_js__WEBPACK_IMPORTED_MODULE_0__[\"chosenShape\"] == _globals__WEBPACK_IMPORTED_MODULE_2__[\"Shapes\"].KITE ? _shapes_js__WEBPACK_IMPORTED_MODULE_4__[\"Kite\"] : _shapes_js__WEBPACK_IMPORTED_MODULE_4__[\"Dart\"];\r\n      visCtx.globalAlpha = .5;\r\n      shapeClass.drawPreview(visCtx, close1);\r\n      visCtx.globalAlpha = 1;\r\n    }\r\n    drawCircle(close1, \"blue\");\r\n  }\r\n\r\n  if (temp1 && tempAlpha > 0) {\r\n    \r\n    visCtx.save();\r\n    visCtx.beginPath();\r\n    let first = true;\r\n    for (let seg of temp1) {\r\n      first = false;\r\n      if (first) visCtx.moveTo(seg.pt1.x, seg.pt1.y);\r\n      else visCtx.lineTo(seg.pt2.x, seg.pt2.y);\r\n    }\r\n    visCtx.closePath();\r\n    tempAlpha = Math.max(0, tempAlpha - .02);\r\n    visCtx.globalAlpha = tempAlpha;\r\n    visCtx.lineWidth = 4;\r\n    visCtx.strokeStyle = \"red\";\r\n    visCtx.stroke()\r\n    visCtx.restore();\r\n  }\r\n\r\n  visCtx.restore();\r\n\r\n  // visCtx.fillText(cursor.x, 20, 20)\r\n  // visCtx.fillText(cursor.y, 20, 40)\r\n  requestAnimationFrame(tick);\r\n}\r\n\r\nlet temp1;\r\nlet tempAlpha = 0\r\n\r\nlet invalid = false;\r\n\r\nlet theta = 0;\r\nlet close1 = null;\r\n\r\nfunction update() {\r\n  let he = closest();\r\n  if (he && he.opp && !he.blue && _cursor_js__WEBPACK_IMPORTED_MODULE_0__[\"chosenShape\"] == _globals__WEBPACK_IMPORTED_MODULE_2__[\"Shapes\"].DART && he.opp.face instanceof _shapes_js__WEBPACK_IMPORTED_MODULE_4__[\"Dart\"]) invalid = true;\r\n  else invalid = false;\r\n\r\n  close1 = he;\r\n  if (_globals__WEBPACK_IMPORTED_MODULE_2__[\"tree\"].empty()) _globals__WEBPACK_IMPORTED_MODULE_2__[\"tree\"].insert(new _halfedge_js__WEBPACK_IMPORTED_MODULE_3__[\"Halfedge\"](null, new _halfedge_js__WEBPACK_IMPORTED_MODULE_3__[\"Point\"](300, 400), new _halfedge_js__WEBPACK_IMPORTED_MODULE_3__[\"Point\"](300, 300), true, true, 0));\r\n\r\n  if (keys[\"w\"]) _globals__WEBPACK_IMPORTED_MODULE_2__[\"camera\"].y -= 5 / _globals__WEBPACK_IMPORTED_MODULE_2__[\"camera\"].scale;\r\n  if (keys[\"s\"]) _globals__WEBPACK_IMPORTED_MODULE_2__[\"camera\"].y += 5 / _globals__WEBPACK_IMPORTED_MODULE_2__[\"camera\"].scale;\r\n  if (keys[\"d\"]) _globals__WEBPACK_IMPORTED_MODULE_2__[\"camera\"].x += 5 / _globals__WEBPACK_IMPORTED_MODULE_2__[\"camera\"].scale;\r\n  if (keys[\"a\"]) _globals__WEBPACK_IMPORTED_MODULE_2__[\"camera\"].x -= 5 / _globals__WEBPACK_IMPORTED_MODULE_2__[\"camera\"].scale;\r\n}\r\n\r\nfunction closest() {\r\n  if (_globals__WEBPACK_IMPORTED_MODULE_2__[\"tree\"].empty()) return null;\r\n  let maxDistSq = _globals__WEBPACK_IMPORTED_MODULE_2__[\"tree\"].isSizeOne() ? null : 100*100\r\n  let res = _globals__WEBPACK_IMPORTED_MODULE_2__[\"tree\"].nearest(_cursor_js__WEBPACK_IMPORTED_MODULE_0__[\"cursor\"], 1, maxDistSq);\r\n  if (res.length == 0) return null;\r\n  let [he] = res[0];\r\n  return he;\r\n}\r\n\r\n_globals__WEBPACK_IMPORTED_MODULE_2__[\"canvas\"].addEventListener(\"mousedown\", e => {\r\n  if (e.button == 0) handlePlace();\r\n  if (e.button == 2) handleRemove();\r\n});\r\n\r\n_globals__WEBPACK_IMPORTED_MODULE_2__[\"canvas\"].addEventListener(\"contextmenu\", e => {\r\n  e.preventDefault();\r\n});\r\n\r\nfunction handlePlace() {\r\n  if (!close1) return;\r\n  if (invalid) return;\r\n  let start = close1;\r\n  let shapeClass = _cursor_js__WEBPACK_IMPORTED_MODULE_0__[\"chosenShape\"] == _globals__WEBPACK_IMPORTED_MODULE_2__[\"Shapes\"].KITE ? _shapes_js__WEBPACK_IMPORTED_MODULE_4__[\"Kite\"] : _shapes_js__WEBPACK_IMPORTED_MODULE_4__[\"Dart\"];\r\n\r\n  let segments = shapeClass.getSegments(close1);\r\n  let nearbyHalfedges = _globals__WEBPACK_IMPORTED_MODULE_2__[\"tree\"].nearest(close1, 10, 150*150);\r\n\r\n  if (!checkForIntersections(segments, nearbyHalfedges)) {\r\n    temp1 = segments;\r\n    tempAlpha = 1;\r\n    return;\r\n  }\r\n\r\n  let newShape = new shapeClass(close1);\r\n  let ptr = start;\r\n  do {\r\n    ptr = ptr.next;\r\n    _globals__WEBPACK_IMPORTED_MODULE_2__[\"tree\"].remove(ptr);\r\n\r\n    if (ptr.opp.face == null) _globals__WEBPACK_IMPORTED_MODULE_2__[\"tree\"].insert(ptr.opp);\r\n\r\n  } while (ptr != start);\r\n  Object(_floor_js__WEBPACK_IMPORTED_MODULE_1__[\"addToFloor\"])(newShape);\r\n}\r\n\r\nfunction checkForIntersections(segments, nearbyHalfedges) {\r\n  for (let [he] of nearbyHalfedges) {\r\n    for (let seg of segments) {\r\n      if (Object(_globals__WEBPACK_IMPORTED_MODULE_2__[\"intersects\"])(seg, he)) return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n\r\nfunction handleRemove() {\r\n  if (!close1) return;\r\n  if (_globals__WEBPACK_IMPORTED_MODULE_2__[\"tree\"].isSizeOne()) return;\r\n  let faceToRemove = close1.opp.face;\r\n  if (!faceToRemove) return;\r\n  let start = close1.opp.face.halfedge;\r\n  let ptr = start;\r\n  do {\r\n    if (ptr.opp.face == null) {\r\n      _globals__WEBPACK_IMPORTED_MODULE_2__[\"tree\"].remove(ptr.opp);\r\n    } else {\r\n      ptr.face = null;\r\n      _globals__WEBPACK_IMPORTED_MODULE_2__[\"tree\"].insert(ptr);\r\n    }\r\n    ptr = ptr.next;\r\n  } while (ptr != start)\r\n\r\n  Object(_floor_js__WEBPACK_IMPORTED_MODULE_1__[\"removeFromFloor\"])(faceToRemove);\r\n}\r\n\r\nlet keys = {};\r\n\r\nwindow.addEventListener(\"keydown\", e => {\r\n  if (e.key == \"+\" || e.key == \"=\") _globals__WEBPACK_IMPORTED_MODULE_2__[\"camera\"].scale += .1;\r\n  if (e.key == \"-\" || e.key == \"_\") _globals__WEBPACK_IMPORTED_MODULE_2__[\"camera\"].scale -= .1;\r\n\r\n  keys[e.key] = true;\r\n});\r\n\r\nwindow.addEventListener(\"mousewheel\", e => {\r\n  if (e.deltaY > 0) _globals__WEBPACK_IMPORTED_MODULE_2__[\"camera\"].zoomAt(_cursor_js__WEBPACK_IMPORTED_MODULE_0__[\"cursor\"].x, _cursor_js__WEBPACK_IMPORTED_MODULE_0__[\"cursor\"].y, -.1)\r\n  else _globals__WEBPACK_IMPORTED_MODULE_2__[\"camera\"].zoomAt(_cursor_js__WEBPACK_IMPORTED_MODULE_0__[\"cursor\"].x, _cursor_js__WEBPACK_IMPORTED_MODULE_0__[\"cursor\"].y, .1)\r\n});\r\n\r\n\r\nwindow.addEventListener(\"keyup\", e => {\r\n  keys[e.key] = false;\r\n});\r\n\r\n\n\n//# sourceURL=webpack:///./src/main.js?");

/***/ }),

/***/ "./src/shapes.js":
/*!***********************!*\
  !*** ./src/shapes.js ***!
  \***********************/
/*! exports provided: Kite, Dart */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Kite\", function() { return Kite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Dart\", function() { return Dart; });\n/* harmony import */ var _vertices__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vertices */ \"./src/vertices.js\");\n/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./globals */ \"./src/globals.js\");\n/* harmony import */ var _halfedge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./halfedge */ \"./src/halfedge.js\");\n\r\n\r\n\r\n\r\nfunction drawVertices(ctx, vertices) {\r\n  ctx.moveTo(vertices[0], vertices[1]);\r\n  ctx.lineTo(vertices[2], vertices[3]);\r\n  ctx.lineTo(vertices[4], vertices[5]);\r\n  ctx.lineTo(vertices[6], vertices[7]);\r\n  ctx.fill();\r\n}\r\n\r\nconst BLUE = true;\r\nconst RED = false;\r\nconst ALPHA = true;\r\nconst BETA = false;\r\n\r\n\r\nfunction alphaAndBlueMatch(a, b) {\r\n  return a.alpha == b.alpha && a.blue == b.blue;\r\n}\r\n\r\n\r\nclass Kite {\r\n  constructor(halfedge) {\r\n    this.halfedge = halfedge;\r\n    if (halfedge.face != null) console.log(\"it has a face!\")\r\n    halfedge.face = this;\r\n\r\n    let [x, y, theta] = Kite.orientationForFit(halfedge);\r\n    this.x = x;\r\n    this.y = y;\r\n    this.theta = theta;\r\n\r\n    let [bottom, left, top, right] = Kite.findPoints(x, y, theta)\r\n\r\n    bottom.halfedge = new _halfedge__WEBPACK_IMPORTED_MODULE_2__[\"Halfedge\"](this, bottom,  left, ALPHA, BLUE, theta - 36);\r\n    left.halfedge   = new _halfedge__WEBPACK_IMPORTED_MODULE_2__[\"Halfedge\"](this, left,     top,  BETA,  RED, theta + 72);\r\n    top.halfedge    = new _halfedge__WEBPACK_IMPORTED_MODULE_2__[\"Halfedge\"](this, top,    right, ALPHA,  RED, theta + 108);\r\n    right.halfedge  = new _halfedge__WEBPACK_IMPORTED_MODULE_2__[\"Halfedge\"](this, right, bottom,  BETA, BLUE, theta - 144);\r\n\r\n    for (let pt of [bottom, left, top, right]) {\r\n      if (alphaAndBlueMatch(pt.halfedge, halfedge)) {\r\n        pt.halfedge = halfedge; //use the halfedge from argument\r\n        continue;\r\n      }\r\n      let [existingHe] = _globals__WEBPACK_IMPORTED_MODULE_1__[\"tree\"].nearest(pt.halfedge, 1)[0];\r\n      if (pt.halfedge.matches(existingHe)) {\r\n        existingHe.face = this;\r\n        _globals__WEBPACK_IMPORTED_MODULE_1__[\"tree\"].remove(existingHe)\r\n        pt.halfedge = existingHe;\r\n      }\r\n    }\r\n\r\n    //set next & prev\r\n    bottom.halfedge.chain(left.halfedge);\r\n    left.halfedge.chain(top.halfedge);\r\n    top.halfedge.chain(right.halfedge);\r\n    right.halfedge.chain(bottom.halfedge);\r\n\r\n    //set opps\r\n    if (!bottom.halfedge.opp) bottom.halfedge.pair(new _halfedge__WEBPACK_IMPORTED_MODULE_2__[\"Halfedge\"](null,  left, bottom,  BETA, BLUE, theta -  36 + 180));\r\n    if (!left.halfedge.opp)   left.halfedge.pair(new _halfedge__WEBPACK_IMPORTED_MODULE_2__[\"Halfedge\"](null,     top,   left, ALPHA,  RED, theta +  72 + 180));\r\n    if (!top.halfedge.opp)    top.halfedge.pair(new _halfedge__WEBPACK_IMPORTED_MODULE_2__[\"Halfedge\"](null,    right,    top,  BETA,  RED, theta + 108 + 180));\r\n    if (!right.halfedge.opp)  right.halfedge.pair(new _halfedge__WEBPACK_IMPORTED_MODULE_2__[\"Halfedge\"](null, bottom,  right, ALPHA, BLUE, theta - 144 + 180));\r\n  }\r\n\r\n  draw(ctx, scale=1, stroke=false) {\r\n    let {x, y, theta} = this;\r\n    Kite.drawKite(ctx, x, y, theta, scale, stroke)\r\n  }\r\n\r\n  static isBottom(halfedge) { return halfedge.alpha && halfedge.blue }\r\n  static isLeft(halfedge) { return !halfedge.alpha && !halfedge.blue }\r\n  static isTop(halfedge) { return halfedge.alpha && !halfedge.blue }\r\n  static isRight(halfedge) { return !halfedge.alpha && halfedge.blue }\r\n\r\n  static translationForFit(halfedge) {\r\n    if (Kite.isBottom(halfedge)) return [_globals__WEBPACK_IMPORTED_MODULE_1__[\"SIN36\"] * 100, (_globals__WEBPACK_IMPORTED_MODULE_1__[\"COS36\"] - 1)*100];\r\n    if (Kite.isLeft(halfedge))   return [0, 0];\r\n    if (Kite.isTop(halfedge))    return [-_globals__WEBPACK_IMPORTED_MODULE_1__[\"SIN36\"] * 100, (_globals__WEBPACK_IMPORTED_MODULE_1__[\"COS36\"] - 1)*100];\r\n    if (Kite.isRight(halfedge))  return [0, -100];\r\n  }\r\n\r\n  static rotationForFit(halfedge) {\r\n    if (Kite.isBottom(halfedge)) return 36;\r\n    if (Kite.isLeft(halfedge))   return -72;\r\n    if (Kite.isTop(halfedge))    return -108;\r\n    if (Kite.isRight(halfedge))  return 144;\r\n  }\r\n\r\n  static orientationForFit(halfedge) {\r\n    let turn = Kite.rotationForFit(halfedge);\r\n    let theta = halfedge.theta + turn;\r\n    theta = Object(_globals__WEBPACK_IMPORTED_MODULE_1__[\"posMod\"])(theta, 360); // 0 is straight up, 90 points right\r\n\r\n    let c = Math.cos(Object(_globals__WEBPACK_IMPORTED_MODULE_1__[\"degrees2Radians\"])(theta));\r\n    let s = Math.sin(Object(_globals__WEBPACK_IMPORTED_MODULE_1__[\"degrees2Radians\"])(theta));\r\n    let t = Kite.translationForFit(halfedge);\r\n    let x = t[0] * c - t[1] * s + halfedge.nextPt.x;\r\n    let y = t[0] * s + t[1] * c + halfedge.nextPt.y;\r\n\r\n    return [x, y, theta];\r\n  }\r\n\r\n  static findPoints(x, y, theta) {\r\n    const verts = Object(_vertices__WEBPACK_IMPORTED_MODULE_0__[\"getVertices\"])(theta, _globals__WEBPACK_IMPORTED_MODULE_1__[\"Shapes\"].KITE);\r\n    let bottom = new _halfedge__WEBPACK_IMPORTED_MODULE_2__[\"Point\"](x + verts[0], y + verts[1]);\r\n    let left   = new _halfedge__WEBPACK_IMPORTED_MODULE_2__[\"Point\"](x + verts[2], y + verts[3]);\r\n    let top    = new _halfedge__WEBPACK_IMPORTED_MODULE_2__[\"Point\"](x + verts[4], y + verts[5]);\r\n    let right  = new _halfedge__WEBPACK_IMPORTED_MODULE_2__[\"Point\"](x + verts[6], y + verts[7]);\r\n    return [bottom, left, top, right];\r\n  }\r\n\r\n  static getSegments(halfedge) {\r\n    let [x, y, theta] = Kite.orientationForFit(halfedge)\r\n    let [b, l, t, r] = Kite.findPoints(x, y, theta);\r\n    let seg1 = { pt1: b, pt2: l, theta: theta - 36 };\r\n    let seg2 = { pt1: l, pt2: t, theta: theta + 72 };\r\n    let seg3 = { pt1: t, pt2: r, theta: theta + 108 };\r\n    let seg4 = { pt1: r, pt2: b, theta: theta - 144 };\r\n    return [seg1, seg2, seg3, seg4];\r\n  }\r\n\r\n  static drawPreview(ctx, halfedge, scale=1, stroke=false) {\r\n    let [x, y, theta] = Kite.orientationForFit(halfedge);\r\n    Kite.drawKite(ctx, x, y, theta, scale, stroke);\r\n  }\r\n\r\n  static drawKite(ctx, x, y, theta, scale=1, stroke=false) {\r\n    ctx.save();\r\n    ctx.translate(x, y);\r\n    ctx.rotate(Object(_globals__WEBPACK_IMPORTED_MODULE_1__[\"degrees2Radians\"])(theta));\r\n    ctx.scale(scale, scale);\r\n\r\n    ctx.beginPath();\r\n    ctx.fillStyle = \"lime\";\r\n    drawVertices(ctx, _vertices__WEBPACK_IMPORTED_MODULE_0__[\"kiteVertices\"][0]);\r\n    if (stroke) ctx.stroke();\r\n\r\n    ctx.lineWidth = 5/scale;\r\n    ctx.beginPath();\r\n    ctx.strokeStyle=\"red\";\r\n    ctx.arc(0, 0, (1-0.61803) * 100, .1*_globals__WEBPACK_IMPORTED_MODULE_1__[\"PI\"], .9*_globals__WEBPACK_IMPORTED_MODULE_1__[\"PI\"]);\r\n    ctx.stroke();\r\n\r\n    ctx.beginPath();\r\n    ctx.strokeStyle=\"blue\";\r\n    ctx.arc(0, 1 * 100, (0.61803) * 100, -.7*_globals__WEBPACK_IMPORTED_MODULE_1__[\"PI\"], -.3*_globals__WEBPACK_IMPORTED_MODULE_1__[\"PI\"]);\r\n    ctx.stroke();\r\n\r\n    ctx.restore();\r\n  }\r\n}\r\n\r\nclass Dart {\r\n  constructor(halfedge) {\r\n    this.halfedge = halfedge;\r\n    if (halfedge.face != null) console.log(\"it has a face!\")\r\n    halfedge.face = this;\r\n    let [x, y, theta] = Dart.orientationForFit(halfedge);\r\n    this.x = x;\r\n    this.y = y;\r\n    this.theta = theta;\r\n\r\n    let [bottom, left, top, right] = Dart.findPoints(x, y, theta);\r\n\r\n    bottom.halfedge = new _halfedge__WEBPACK_IMPORTED_MODULE_2__[\"Halfedge\"](this, bottom,  left,  BETA,  RED, theta - 108);\r\n    left.halfedge   = new _halfedge__WEBPACK_IMPORTED_MODULE_2__[\"Halfedge\"](this, left,     top, ALPHA, BLUE, theta + 36);\r\n    top.halfedge    = new _halfedge__WEBPACK_IMPORTED_MODULE_2__[\"Halfedge\"](this, top,    right,  BETA, BLUE, theta + 144);\r\n    right.halfedge  = new _halfedge__WEBPACK_IMPORTED_MODULE_2__[\"Halfedge\"](this, right, bottom, ALPHA,  RED, theta - 72);\r\n\r\n    for (let pt of [bottom, left, top, right]) {\r\n      if (alphaAndBlueMatch(pt.halfedge, halfedge)) {\r\n        pt.halfedge = halfedge; //use the halfedge from argument\r\n        continue;\r\n      }\r\n      let [existingHe] = _globals__WEBPACK_IMPORTED_MODULE_1__[\"tree\"].nearest(pt.halfedge, 1)[0];\r\n      if (pt.halfedge.matches(existingHe)) {\r\n        existingHe.face = this;\r\n        _globals__WEBPACK_IMPORTED_MODULE_1__[\"tree\"].remove(existingHe)\r\n        pt.halfedge = existingHe;\r\n      }\r\n    }\r\n\r\n    //set next & prev\r\n    bottom.halfedge.chain(left.halfedge);\r\n    left.halfedge.chain(top.halfedge);\r\n    top.halfedge.chain(right.halfedge);\r\n    right.halfedge.chain(bottom.halfedge);\r\n\r\n    //set opps\r\n    if (!bottom.halfedge.opp) bottom.halfedge.pair(new _halfedge__WEBPACK_IMPORTED_MODULE_2__[\"Halfedge\"](null,  left, bottom, ALPHA,  RED, theta - 108 + 180));\r\n    if (!left.halfedge.opp)   left.halfedge.pair(new _halfedge__WEBPACK_IMPORTED_MODULE_2__[\"Halfedge\"](null,     top,   left,  BETA, BLUE, theta +  36 + 180));\r\n    if (!top.halfedge.opp)    top.halfedge.pair(new _halfedge__WEBPACK_IMPORTED_MODULE_2__[\"Halfedge\"](null,    right,    top, ALPHA, BLUE, theta + 144 + 180));\r\n    if (!right.halfedge.opp)  right.halfedge.pair(new _halfedge__WEBPACK_IMPORTED_MODULE_2__[\"Halfedge\"](null, bottom,  right,  BETA,  RED, theta -  72 + 180));\r\n  }\r\n\r\n  draw(ctx, scale=1, stroke=false) {\r\n    let {x, y, theta} = this;\r\n    Dart.drawDart(ctx, x, y, theta, scale, stroke)\r\n  }\r\n\r\n  static isBottom(halfedge) { return !halfedge.alpha && !halfedge.blue }\r\n  static isLeft(halfedge) { return halfedge.alpha && halfedge.blue }\r\n  static isTop(halfedge) { return !halfedge.alpha && halfedge.blue }\r\n  static isRight(halfedge) { return halfedge.alpha && !halfedge.blue }\r\n\r\n  static translationForFit(halfedge) {\r\n    if (Dart.isBottom(halfedge)) return [_globals__WEBPACK_IMPORTED_MODULE_1__[\"SIN36\"] * 100, (_globals__WEBPACK_IMPORTED_MODULE_1__[\"COS36\"]-1) * 100];\r\n    if (Dart.isLeft(halfedge))   return [0, (_globals__WEBPACK_IMPORTED_MODULE_1__[\"PHI\"]-1) * 100];\r\n    if (Dart.isTop(halfedge))    return [-_globals__WEBPACK_IMPORTED_MODULE_1__[\"SIN36\"] * 100, (_globals__WEBPACK_IMPORTED_MODULE_1__[\"COS36\"]-1) * 100];\r\n    if (Dart.isRight(halfedge))  return [0, 0]; //good\r\n  }\r\n\r\n  static rotationForFit(halfedge) {\r\n    if (Dart.isBottom(halfedge)) return 108;\r\n    if (Dart.isLeft(halfedge))   return -36;\r\n    if (Dart.isTop(halfedge))    return -144;\r\n    if (Dart.isRight(halfedge))  return 72;\r\n  }\r\n\r\n  static orientationForFit(halfedge) {\r\n    let turn = Dart.rotationForFit(halfedge);\r\n    let theta = halfedge.theta + turn;\r\n    theta = Object(_globals__WEBPACK_IMPORTED_MODULE_1__[\"posMod\"])(theta, 360); // 0 is straight up, 90 points right\r\n\r\n    let c = Math.cos(Object(_globals__WEBPACK_IMPORTED_MODULE_1__[\"degrees2Radians\"])(theta));\r\n    let s = Math.sin(Object(_globals__WEBPACK_IMPORTED_MODULE_1__[\"degrees2Radians\"])(theta));\r\n    let t = Dart.translationForFit(halfedge);\r\n    let x = t[0] * c - t[1] * s + halfedge.nextPt.x;\r\n    let y = t[0] * s + t[1] * c + halfedge.nextPt.y;\r\n\r\n    return [x, y, theta];\r\n  }\r\n\r\n  static findPoints(x, y, theta) {\r\n    const verts = Object(_vertices__WEBPACK_IMPORTED_MODULE_0__[\"getVertices\"])(theta, _globals__WEBPACK_IMPORTED_MODULE_1__[\"Shapes\"].DART);\r\n    let bottom = new _halfedge__WEBPACK_IMPORTED_MODULE_2__[\"Point\"](x + verts[0], y + verts[1]);\r\n    let left   = new _halfedge__WEBPACK_IMPORTED_MODULE_2__[\"Point\"](x + verts[2], y + verts[3]);\r\n    let top    = new _halfedge__WEBPACK_IMPORTED_MODULE_2__[\"Point\"](x + verts[4], y + verts[5]);\r\n    let right  = new _halfedge__WEBPACK_IMPORTED_MODULE_2__[\"Point\"](x + verts[6], y + verts[7]);\r\n    return [bottom, left, top, right];\r\n  }\r\n\r\n  static getSegments(halfedge) {\r\n    let [x, y, theta] = Dart.orientationForFit(halfedge)\r\n    let [b, l, t, r] = Dart.findPoints(x, y, theta);\r\n    let seg1 = { pt1: b, pt2: l, theta: theta - 108};\r\n    let seg2 = { pt1: l, pt2: t, theta: theta + 36};\r\n    let seg3 = { pt1: t, pt2: r, theta: theta + 144};\r\n    let seg4 = { pt1: r, pt2: b, theta: theta - 72};\r\n    return [seg1, seg2, seg3, seg4];\r\n  }\r\n\r\n  static drawPreview(ctx, halfedge, scale=1, stroke=false) {\r\n    let [x, y, theta] = Dart.orientationForFit(halfedge);\r\n    Dart.drawDart(ctx, x, y, theta, scale, stroke);\r\n  }\r\n\r\n  static drawDart(ctx, x, y, theta, scale=1, stroke=false) {\r\n    ctx.save();\r\n    ctx.translate(x, y);\r\n    ctx.rotate(Object(_globals__WEBPACK_IMPORTED_MODULE_1__[\"degrees2Radians\"])(theta));\r\n    ctx.scale(scale, scale);\r\n\r\n    ctx.beginPath();\r\n    ctx.fillStyle = \"yellow\";\r\n    drawVertices(ctx, _vertices__WEBPACK_IMPORTED_MODULE_0__[\"dartVertices\"][0]);\r\n    if (stroke) ctx.stroke();\r\n\r\n    ctx.lineWidth = 5/scale;\r\n    ctx.beginPath();\r\n    ctx.strokeStyle=\"red\";\r\n    ctx.arc(0, 0, (1-0.61803)*0.61803 * 100, .9*_globals__WEBPACK_IMPORTED_MODULE_1__[\"PI\"], 2.1*_globals__WEBPACK_IMPORTED_MODULE_1__[\"PI\"]);\r\n    ctx.stroke();\r\n\r\n    ctx.beginPath();\r\n    ctx.strokeStyle=\"blue\";\r\n    ctx.arc(0, -0.61803 * 100, (1-0.61803) * 100, .3*_globals__WEBPACK_IMPORTED_MODULE_1__[\"PI\"], .7*_globals__WEBPACK_IMPORTED_MODULE_1__[\"PI\"]);\r\n    ctx.stroke();\r\n\r\n    ctx.restore();\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/shapes.js?");

/***/ }),

/***/ "./src/vertices.js":
/*!*************************!*\
  !*** ./src/vertices.js ***!
  \*************************/
/*! exports provided: kiteVertices, dartVertices, getVertices */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"kiteVertices\", function() { return kiteVertices; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dartVertices\", function() { return dartVertices; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getVertices\", function() { return getVertices; });\n/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals */ \"./src/globals.js\");\n\r\n\r\nconst k = [\r\n  0, 1,\r\n  -_globals__WEBPACK_IMPORTED_MODULE_0__[\"SIN36\"], 1 - _globals__WEBPACK_IMPORTED_MODULE_0__[\"COS36\"],\r\n  0, 0,\r\n  _globals__WEBPACK_IMPORTED_MODULE_0__[\"SIN36\"], 1 - _globals__WEBPACK_IMPORTED_MODULE_0__[\"COS36\"],\r\n].map(x => x * 100);\r\n\r\nconst d = [\r\n  0, 0,\r\n  -_globals__WEBPACK_IMPORTED_MODULE_0__[\"SIN36\"], 1 - _globals__WEBPACK_IMPORTED_MODULE_0__[\"COS36\"],\r\n  0, 1 - _globals__WEBPACK_IMPORTED_MODULE_0__[\"PHI\"],\r\n  _globals__WEBPACK_IMPORTED_MODULE_0__[\"SIN36\"], 1 - _globals__WEBPACK_IMPORTED_MODULE_0__[\"COS36\"],\r\n].map(x => x * 100);\r\n\r\nconst pi = Math.PI;\r\nconst kiteVertices = {\r\n  \"0\": rotateVertices(k, 0),\r\n  \"36\": rotateVertices(k, pi/5),\r\n  \"72\": rotateVertices(k, 2*pi/5),\r\n  \"108\": rotateVertices(k, 3*pi/5),\r\n  \"144\": rotateVertices(k, 4*pi/5),\r\n  \"180\": rotateVertices(k, 5*pi/5),\r\n  \"216\": rotateVertices(k, 6*pi/5),\r\n  \"252\": rotateVertices(k, 7*pi/5),\r\n  \"288\": rotateVertices(k, 8*pi/5),\r\n  \"324\": rotateVertices(k, 9*pi/5),\r\n}\r\n\r\nconst dartVertices = {\r\n  \"0\": rotateVertices(d, 0),\r\n  \"36\": rotateVertices(d, pi/5),\r\n  \"72\": rotateVertices(d, 2*pi/5),\r\n  \"108\": rotateVertices(d, 3*pi/5),\r\n  \"144\": rotateVertices(d, 4*pi/5),\r\n  \"180\": rotateVertices(d, 5*pi/5),\r\n  \"216\": rotateVertices(d, 6*pi/5),\r\n  \"252\": rotateVertices(d, 7*pi/5),\r\n  \"288\": rotateVertices(d, 8*pi/5),\r\n  \"324\": rotateVertices(d, 9*pi/5),\r\n}\r\n\r\n\r\nfunction getVertices(angle, shapeType) {\r\n  let seg = Math.round((angle) / 36) % 10;\r\n  seg = Object(_globals__WEBPACK_IMPORTED_MODULE_0__[\"posMod\"])(seg, 10);\r\n  let key = seg * 36;\r\n  if (shapeType == _globals__WEBPACK_IMPORTED_MODULE_0__[\"Shapes\"].KITE) {\r\n    return kiteVertices[key]\r\n  }\r\n  return dartVertices[key];\r\n}\r\n\r\n\r\nfunction rotateVertices(vertices, angle) {\r\n  let s = Math.sin(angle);\r\n  let c = Math.cos(angle);\r\n  let newV = [];\r\n  for (let i = 0; i < vertices.length; i += 2) {\r\n    let xnew = vertices[i] * c - vertices[i + 1] * s;\r\n    let ynew = vertices[i] * s + vertices[i + 1] * c;\r\n    newV.push(xnew)\r\n    newV.push(ynew)\r\n  }\r\n  return newV;\r\n}\r\n\n\n//# sourceURL=webpack:///./src/vertices.js?");

/***/ })

/******/ });