/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/cursor.js":
/*!***********************!*\
  !*** ./src/cursor.js ***!
  \***********************/
/*! exports provided: cursor, chosenShape, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cursor\", function() { return cursor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"chosenShape\", function() { return chosenShape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return drawCursor; });\n/* harmony import */ var _shapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shapes.js */ \"./src/shapes.js\");\n/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./globals */ \"./src/globals.js\");\n/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./main */ \"./src/main.js\");\n\r\n\r\n\r\n\r\nconst cursorCtx = document.createElement(\"canvas\").getContext(\"2d\");\r\ncursorCtx.canvas.width = _globals__WEBPACK_IMPORTED_MODULE_1__[\"W\"];\r\ncursorCtx.canvas.height = _globals__WEBPACK_IMPORTED_MODULE_1__[\"H\"];\r\n\r\nconst cursor = {x: 0, y: 0};\r\nlet chosenShape = _globals__WEBPACK_IMPORTED_MODULE_1__[\"Shapes\"].KITE;\r\n\r\nfunction drawCursor(ctx) {\r\n  cursorCtx.clearRect(0, 0, _globals__WEBPACK_IMPORTED_MODULE_1__[\"W\"], _globals__WEBPACK_IMPORTED_MODULE_1__[\"H\"]);\r\n\r\n  ctx.drawImage(cursorCtx.canvas, 0, 0);\r\n}\r\n\r\nconst canvasClientRatio = 1;\r\ncanvas.addEventListener(\"mousemove\", e => {\r\n  cursor.x = e.offsetX * canvasClientRatio;\r\n  cursor.y = e.offsetY * canvasClientRatio;\r\n});\r\n\r\nwindow.addEventListener(\"mousewheel\", e => {\r\n  chosenShape = 1 - chosenShape;\r\n});\r\n\r\n\n\n//# sourceURL=webpack:///./src/cursor.js?");

/***/ }),

/***/ "./src/floor.js":
/*!**********************!*\
  !*** ./src/floor.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return drawFloor; });\n/* harmony import */ var _shapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shapes.js */ \"./src/shapes.js\");\n/* harmony import */ var _cursor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cursor.js */ \"./src/cursor.js\");\n/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./globals */ \"./src/globals.js\");\n/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./main.js */ \"./src/main.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nconst tileCtx = document.createElement(\"canvas\").getContext(\"2d\");\r\ntileCtx.canvas.width = _globals__WEBPACK_IMPORTED_MODULE_2__[\"W\"];\r\ntileCtx.canvas.height = _globals__WEBPACK_IMPORTED_MODULE_2__[\"H\"];\r\n\r\nsetTimeout( () => _main_js__WEBPACK_IMPORTED_MODULE_3__[\"firstKite\"].draw(tileCtx), 10);\r\n\r\nfunction drawFloor(ctx) {\r\n  ctx.drawImage(tileCtx.canvas, 0, 0);\r\n}\r\n\r\n\r\n_globals__WEBPACK_IMPORTED_MODULE_2__[\"canvas\"].addEventListener(\"mousedown\", () => {\r\n  _main_js__WEBPACK_IMPORTED_MODULE_3__[\"ghostShape\"].draw(tileCtx)\r\n});\r\n\r\nconst clearBtn = document.getElementById(\"clear-btn\");\r\nclearBtn.addEventListener(\"click\", () => tileCtx.clearRect(0, 0, _globals__WEBPACK_IMPORTED_MODULE_2__[\"W\"], _globals__WEBPACK_IMPORTED_MODULE_2__[\"H\"]))\r\n\n\n//# sourceURL=webpack:///./src/floor.js?");

/***/ }),

/***/ "./src/globals.js":
/*!************************!*\
  !*** ./src/globals.js ***!
  \************************/
/*! exports provided: W, H, PHI, SIN36, COS36, PI, TAU, Shapes, canvas, dist, near, midpoint, radians2Degrees, degrees2Radians, posMod, tree */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"W\", function() { return W; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"H\", function() { return H; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PHI\", function() { return PHI; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SIN36\", function() { return SIN36; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COS36\", function() { return COS36; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PI\", function() { return PI; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TAU\", function() { return TAU; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Shapes\", function() { return Shapes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"canvas\", function() { return canvas; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dist\", function() { return dist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"near\", function() { return near; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"midpoint\", function() { return midpoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"radians2Degrees\", function() { return radians2Degrees; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"degrees2Radians\", function() { return degrees2Radians; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"posMod\", function() { return posMod; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tree\", function() { return tree; });\n/* harmony import */ var _kdTree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./kdTree */ \"./src/kdTree.js\");\n/* harmony import */ var _kdTree__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_kdTree__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\nconst W = 600;\r\nconst H = 600;\r\n\r\nconst PHI = 1.618033988749895;\r\nconst SIN36 = 0.5877852522924731;\r\nconst COS36 = 0.8090169943749474;\r\nconst PI = Math.PI;\r\nconst TAU = PI * 2;\r\n\r\nconst Shapes = { KITE: 0, DART: 1 };\r\n\r\nconst canvas = document.getElementById(\"canvas\");\r\n\r\nfunction dist(a, b) {\r\n  if (a == null || b == null) return Infinity;\r\n  const dx = a.x - b.x;\r\n  const dy = a.y - b.y;\r\n  return dx*dx + dy*dy;\r\n}\r\n\r\n\r\nfunction near(a, b) {\r\n  if (a == b) return true;\r\n  return dist(a, b) < 1;\r\n}\r\n\r\nfunction midpoint(a, b) {\r\n  const dx = a.x - b.x;\r\n  const dy = a.y - b.y;\r\n  return { \r\n    x: b.x + dx/2,\r\n    y: b.y + dy/2\r\n  }\r\n}\r\n\r\nfunction radians2Degrees(rad)\r\n{\r\n  return rad * (180/PI);\r\n}\r\n\r\nfunction degrees2Radians(deg)\r\n{\r\n  return deg * (PI/180);\r\n}\r\n\r\n\r\nfunction posMod(x, n) {\r\n  while (x < 0) x += n;\r\n  return x % n\r\n}\r\n\r\n\r\nlet tree = new _kdTree__WEBPACK_IMPORTED_MODULE_0__[\"kdTree\"]([], dist, [\"x\", \"y\"]);\r\n\r\nwindow.tree = tree;\r\n\n\n//# sourceURL=webpack:///./src/globals.js?");

/***/ }),

/***/ "./src/kdTree.js":
/*!***********************!*\
  !*** ./src/kdTree.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\r\n * k-d Tree JavaScript - V 1.01\r\n *\r\n * https://github.com/ubilabs/kd-tree-javascript\r\n *\r\n * @author Mircea Pricop <pricop@ubilabs.net>, 2012\r\n * @author Martin Kleppe <kleppe@ubilabs.net>, 2012\r\n * @author Ubilabs http://ubilabs.net, 2012\r\n * @license MIT License <http://www.opensource.org/licenses/mit-license.php>\r\n */\r\n\r\n(function (root, factory) {\r\n  if (true) {\r\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n  } else {}\r\n}(this, function (exports) {\r\nfunction Node(obj, dimension, parent) {\r\n  this.obj = obj;\r\n  this.left = null;\r\n  this.right = null;\r\n  this.parent = parent;\r\n  this.dimension = dimension;\r\n}\r\n\r\nfunction kdTree(points, metric, dimensions) {\r\n\r\n  var self = this;\r\n\r\n  function buildTree(points, depth, parent) {\r\n    var dim = depth % dimensions.length,\r\n      median,\r\n      node;\r\n\r\n    if (points.length === 0) {\r\n      return null;\r\n    }\r\n    if (points.length === 1) {\r\n      return new Node(points[0], dim, parent);\r\n    }\r\n\r\n    points.sort(function (a, b) {\r\n      return a[dimensions[dim]] - b[dimensions[dim]];\r\n    });\r\n\r\n    median = Math.floor(points.length / 2);\r\n    node = new Node(points[median], dim, parent);\r\n    node.left = buildTree(points.slice(0, median), depth + 1, node);\r\n    node.right = buildTree(points.slice(median + 1), depth + 1, node);\r\n\r\n    return node;\r\n  }\r\n\r\n  // Reloads a serialied tree\r\n  function loadTree (data) {\r\n    // Just need to restore the `parent` parameter\r\n    self.root = data;\r\n\r\n    function restoreParent (root) {\r\n      if (root.left) {\r\n        root.left.parent = root;\r\n        restoreParent(root.left);\r\n      }\r\n\r\n      if (root.right) {\r\n        root.right.parent = root;\r\n        restoreParent(root.right);\r\n      }\r\n    }\r\n\r\n    restoreParent(self.root);\r\n  }\r\n\r\n  // If points is not an array, assume we're loading a pre-built tree\r\n  if (!Array.isArray(points)) loadTree(points, metric, dimensions);\r\n  else this.root = buildTree(points, 0, null);\r\n\r\n  // Convert to a JSON serializable structure; this just requires removing\r\n  // the `parent` property\r\n  this.toJSON = function (src) {\r\n    if (!src) src = this.root;\r\n    var dest = new Node(src.obj, src.dimension, null);\r\n    if (src.left) dest.left = self.toJSON(src.left);\r\n    if (src.right) dest.right = self.toJSON(src.right);\r\n    return dest;\r\n  };\r\n\r\n  this.insert = function (point) {\r\n    function innerSearch(node, parent) {\r\n\r\n      if (node === null) {\r\n        return parent;\r\n      }\r\n\r\n      var dimension = dimensions[node.dimension];\r\n      if (point[dimension] < node.obj[dimension]) {\r\n        return innerSearch(node.left, node);\r\n      } else {\r\n        return innerSearch(node.right, node);\r\n      }\r\n    }\r\n\r\n    var insertPosition = innerSearch(this.root, null),\r\n      newNode,\r\n      dimension;\r\n\r\n    if (insertPosition === null) {\r\n      this.root = new Node(point, 0, null);\r\n      return;\r\n    }\r\n\r\n    newNode = new Node(point, (insertPosition.dimension + 1) % dimensions.length, insertPosition);\r\n    dimension = dimensions[insertPosition.dimension];\r\n\r\n    if (point[dimension] < insertPosition.obj[dimension]) {\r\n      insertPosition.left = newNode;\r\n    } else {\r\n      insertPosition.right = newNode;\r\n    }\r\n  };\r\n\r\n  this.remove = function (point) {\r\n    var node;\r\n\r\n    function nodeSearch(node) {\r\n      if (node === null) {\r\n        return null;\r\n      }\r\n\r\n      if (node.obj === point) {\r\n        return node;\r\n      }\r\n\r\n      var dimension = dimensions[node.dimension];\r\n\r\n      if (point[dimension] < node.obj[dimension]) {\r\n        return nodeSearch(node.left, node);\r\n      } else {\r\n        return nodeSearch(node.right, node);\r\n      }\r\n    }\r\n\r\n    function removeNode(node) {\r\n      var nextNode,\r\n        nextObj,\r\n        pDimension;\r\n\r\n      function findMin(node, dim) {\r\n        var dimension,\r\n          own,\r\n          left,\r\n          right,\r\n          min;\r\n\r\n        if (node === null) {\r\n          return null;\r\n        }\r\n\r\n        dimension = dimensions[dim];\r\n\r\n        if (node.dimension === dim) {\r\n          if (node.left !== null) {\r\n            return findMin(node.left, dim);\r\n          }\r\n          return node;\r\n        }\r\n\r\n        own = node.obj[dimension];\r\n        left = findMin(node.left, dim);\r\n        right = findMin(node.right, dim);\r\n        min = node;\r\n\r\n        if (left !== null && left.obj[dimension] < own) {\r\n          min = left;\r\n        }\r\n        if (right !== null && right.obj[dimension] < min.obj[dimension]) {\r\n          min = right;\r\n        }\r\n        return min;\r\n      }\r\n\r\n      if (node.left === null && node.right === null) {\r\n        if (node.parent === null) {\r\n          self.root = null;\r\n          return;\r\n        }\r\n\r\n        pDimension = dimensions[node.parent.dimension];\r\n\r\n        if (node.obj[pDimension] < node.parent.obj[pDimension]) {\r\n          node.parent.left = null;\r\n        } else {\r\n          node.parent.right = null;\r\n        }\r\n        return;\r\n      }\r\n\r\n      // If the right subtree is not empty, swap with the minimum element on the\r\n      // node's dimension. If it is empty, we swap the left and right subtrees and\r\n      // do the same.\r\n      if (node.right !== null) {\r\n        nextNode = findMin(node.right, node.dimension);\r\n        nextObj = nextNode.obj;\r\n        removeNode(nextNode);\r\n        node.obj = nextObj;\r\n      } else {\r\n        nextNode = findMin(node.left, node.dimension);\r\n        nextObj = nextNode.obj;\r\n        removeNode(nextNode);\r\n        node.right = node.left;\r\n        node.left = null;\r\n        node.obj = nextObj;\r\n      }\r\n\r\n    }\r\n\r\n    node = nodeSearch(self.root);\r\n\r\n    if (node === null) { return; }\r\n\r\n    removeNode(node);\r\n  };\r\n\r\n  this.nearest = function (point, maxNodes=1, maxDistance) {\r\n    var i,\r\n      result,\r\n      bestNodes;\r\n\r\n    bestNodes = new BinaryHeap(\r\n      function (e) { return -e[1]; }\r\n    );\r\n\r\n    function nearestSearch(node) {\r\n      var bestChild,\r\n        dimension = dimensions[node.dimension],\r\n        ownDistance = metric(point, node.obj),\r\n        linearPoint = {},\r\n        linearDistance,\r\n        otherChild,\r\n        i;\r\n\r\n      function saveNode(node, distance) {\r\n        bestNodes.push([node, distance]);\r\n        if (bestNodes.size() > maxNodes) {\r\n          bestNodes.pop();\r\n        }\r\n      }\r\n\r\n      for (i = 0; i < dimensions.length; i += 1) {\r\n        if (i === node.dimension) {\r\n          linearPoint[dimensions[i]] = point[dimensions[i]];\r\n        } else {\r\n          linearPoint[dimensions[i]] = node.obj[dimensions[i]];\r\n        }\r\n      }\r\n\r\n      linearDistance = metric(linearPoint, node.obj);\r\n\r\n      if (node.right === null && node.left === null) {\r\n        if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {\r\n          saveNode(node, ownDistance);\r\n        }\r\n        return;\r\n      }\r\n\r\n      if (node.right === null) {\r\n        bestChild = node.left;\r\n      } else if (node.left === null) {\r\n        bestChild = node.right;\r\n      } else {\r\n        if (point[dimension] < node.obj[dimension]) {\r\n          bestChild = node.left;\r\n        } else {\r\n          bestChild = node.right;\r\n        }\r\n      }\r\n\r\n      nearestSearch(bestChild);\r\n\r\n      if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {\r\n        saveNode(node, ownDistance);\r\n      }\r\n\r\n      if (bestNodes.size() < maxNodes || Math.abs(linearDistance) < bestNodes.peek()[1]) {\r\n        if (bestChild === node.left) {\r\n          otherChild = node.right;\r\n        } else {\r\n          otherChild = node.left;\r\n        }\r\n        if (otherChild !== null) {\r\n          nearestSearch(otherChild);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (maxDistance) {\r\n      for (i = 0; i < maxNodes; i += 1) {\r\n        bestNodes.push([null, maxDistance]);\r\n      }\r\n    }\r\n\r\n    if(self.root)\r\n      nearestSearch(self.root);\r\n\r\n    result = [];\r\n\r\n    for (i = 0; i < Math.min(maxNodes, bestNodes.content.length); i += 1) {\r\n      if (bestNodes.content[i][0]) {\r\n        result.push([bestNodes.content[i][0].obj, bestNodes.content[i][1]]);\r\n      }\r\n    }\r\n    return result;\r\n  };\r\n\r\n  this.balanceFactor = function () {\r\n    function height(node) {\r\n      if (node === null) {\r\n        return 0;\r\n      }\r\n      return Math.max(height(node.left), height(node.right)) + 1;\r\n    }\r\n\r\n    function count(node) {\r\n      if (node === null) {\r\n        return 0;\r\n      }\r\n      return count(node.left) + count(node.right) + 1;\r\n    }\r\n\r\n    return height(self.root) / (Math.log(count(self.root)) / Math.log(2));\r\n  };\r\n}\r\n\r\n// Binary heap implementation from:\r\n// http://eloquentjavascript.net/appendix2.html\r\n\r\nfunction BinaryHeap(scoreFunction){\r\n  this.content = [];\r\n  this.scoreFunction = scoreFunction;\r\n}\r\n\r\nBinaryHeap.prototype = {\r\n  push: function(element) {\r\n    // Add the new element to the end of the array.\r\n    this.content.push(element);\r\n    // Allow it to bubble up.\r\n    this.bubbleUp(this.content.length - 1);\r\n  },\r\n\r\n  pop: function() {\r\n    // Store the first element so we can return it later.\r\n    var result = this.content[0];\r\n    // Get the element at the end of the array.\r\n    var end = this.content.pop();\r\n    // If there are any elements left, put the end element at the\r\n    // start, and let it sink down.\r\n    if (this.content.length > 0) {\r\n      this.content[0] = end;\r\n      this.sinkDown(0);\r\n    }\r\n    return result;\r\n  },\r\n\r\n  peek: function() {\r\n    return this.content[0];\r\n  },\r\n\r\n  remove: function(node) {\r\n    var len = this.content.length;\r\n    // To remove a value, we must search through the array to find\r\n    // it.\r\n    for (var i = 0; i < len; i++) {\r\n      if (this.content[i] == node) {\r\n        // When it is found, the process seen in 'pop' is repeated\r\n        // to fill up the hole.\r\n        var end = this.content.pop();\r\n        if (i != len - 1) {\r\n          this.content[i] = end;\r\n          if (this.scoreFunction(end) < this.scoreFunction(node))\r\n            this.bubbleUp(i);\r\n          else\r\n            this.sinkDown(i);\r\n        }\r\n        return;\r\n      }\r\n    }\r\n    throw new Error(\"Node not found.\");\r\n  },\r\n\r\n  size: function() {\r\n    return this.content.length;\r\n  },\r\n\r\n  bubbleUp: function(n) {\r\n    // Fetch the element that has to be moved.\r\n    var element = this.content[n];\r\n    // When at 0, an element can not go up any further.\r\n    while (n > 0) {\r\n      // Compute the parent element's index, and fetch it.\r\n      var parentN = Math.floor((n + 1) / 2) - 1,\r\n          parent = this.content[parentN];\r\n      // Swap the elements if the parent is greater.\r\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\r\n        this.content[parentN] = element;\r\n        this.content[n] = parent;\r\n        // Update 'n' to continue at the new position.\r\n        n = parentN;\r\n      }\r\n      // Found a parent that is less, no need to move it further.\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  },\r\n\r\n  sinkDown: function(n) {\r\n    // Look up the target element and its score.\r\n    var length = this.content.length,\r\n        element = this.content[n],\r\n        elemScore = this.scoreFunction(element);\r\n\r\n    while(true) {\r\n      // Compute the indices of the child elements.\r\n      var child2N = (n + 1) * 2, child1N = child2N - 1;\r\n      // This is used to store the new position of the element,\r\n      // if any.\r\n      var swap = null;\r\n      // If the first child exists (is inside the array)...\r\n      if (child1N < length) {\r\n        // Look it up and compute its score.\r\n        var child1 = this.content[child1N],\r\n            child1Score = this.scoreFunction(child1);\r\n        // If the score is less than our element's, we need to swap.\r\n        if (child1Score < elemScore)\r\n          swap = child1N;\r\n      }\r\n      // Do the same checks for the other child.\r\n      if (child2N < length) {\r\n        var child2 = this.content[child2N],\r\n            child2Score = this.scoreFunction(child2);\r\n        if (child2Score < (swap == null ? elemScore : child1Score)){\r\n          swap = child2N;\r\n        }\r\n      }\r\n\r\n      // If the element needs to be moved, swap it, and continue.\r\n      if (swap != null) {\r\n        this.content[n] = this.content[swap];\r\n        this.content[swap] = element;\r\n        n = swap;\r\n      }\r\n      // Otherwise, we are done.\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nexports.kdTree = kdTree;\r\nexports.BinaryHeap = BinaryHeap;\r\n}));\n\n//# sourceURL=webpack:///./src/kdTree.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! exports provided: firstKite, theta, ghostShape */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"firstKite\", function() { return firstKite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"theta\", function() { return theta; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ghostShape\", function() { return ghostShape; });\n/* harmony import */ var _cursor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cursor.js */ \"./src/cursor.js\");\n/* harmony import */ var _floor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./floor.js */ \"./src/floor.js\");\n/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./globals */ \"./src/globals.js\");\n/* harmony import */ var _shapes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shapes.js */ \"./src/shapes.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst visCtx = _globals__WEBPACK_IMPORTED_MODULE_2__[\"canvas\"].getContext(\"2d\");\r\nvisCtx.canvas.width = _globals__WEBPACK_IMPORTED_MODULE_2__[\"W\"];\r\nvisCtx.canvas.width = _globals__WEBPACK_IMPORTED_MODULE_2__[\"H\"];\r\n\r\nlet firstKite = new _shapes_js__WEBPACK_IMPORTED_MODULE_3__[\"Kite\"](300, 400, 180)\r\n\r\n\r\n_globals__WEBPACK_IMPORTED_MODULE_2__[\"tree\"].insert(firstKite.pts[0]);\r\n_globals__WEBPACK_IMPORTED_MODULE_2__[\"tree\"].insert(firstKite.pts[1]);\r\n_globals__WEBPACK_IMPORTED_MODULE_2__[\"tree\"].insert(firstKite.pts[2]);\r\n_globals__WEBPACK_IMPORTED_MODULE_2__[\"tree\"].insert(firstKite.pts[3]);\r\n\r\n\r\nrequestAnimationFrame(tick);\r\n\r\nlet origin = firstKite.pts[1];\r\nconst maxDepth = 20\r\nfunction drawPath(ctx) {\r\n  let ptr = origin;\r\n  ctx.beginPath();\r\n  ctx.moveTo(ptr.x, ptr.y);\r\n  ptr = ptr.next;\r\n  let i = 0;\r\n  while (ptr != origin && i < maxDepth) {\r\n    ctx.lineTo(ptr.x, ptr.y);\r\n    ptr = ptr.next;\r\n    i ++;\r\n  }\r\n  ctx.lineTo(ptr.x, ptr.y);\r\n  ctx.lineJoin = \"round\";\r\n  ctx.lineWidth = 5;\r\n  ctx.strokeStyle = \"aqua\";\r\n  ctx.stroke();\r\n  ctx.lineWidth = 2;\r\n}\r\n\r\nfunction tick() {\r\n  visCtx.clearRect(0, 0, _globals__WEBPACK_IMPORTED_MODULE_2__[\"W\"], _globals__WEBPACK_IMPORTED_MODULE_2__[\"H\"]);\r\n  update();\r\n  Object(_floor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(visCtx);\r\n  Object(_cursor_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(visCtx);\r\n\r\n  // draw focus circles\r\n  visCtx.beginPath();\r\n  visCtx.strokeStyle = \"yellow\";\r\n  visCtx.arc(focus1.x, focus1.y, 10, 0, Math.PI * 2);\r\n  visCtx.stroke();\r\n  visCtx.closePath();\r\n\r\n  visCtx.beginPath();\r\n  visCtx.strokeStyle = \"white\";\r\n  visCtx.arc(focus1.next.x, focus1.next.y, 10, 0, Math.PI * 2);\r\n  visCtx.stroke();\r\n  visCtx.closePath();\r\n\r\n  visCtx.beginPath();\r\n  visCtx.strokeStyle = \"black\";\r\n  visCtx.arc(focus1.prev.x, focus1.prev.y, 10, 0, Math.PI * 2);\r\n  visCtx.stroke();\r\n  visCtx.closePath();\r\n\r\n  visCtx.fillText(_cursor_js__WEBPACK_IMPORTED_MODULE_0__[\"cursor\"].x + \" \" + _cursor_js__WEBPACK_IMPORTED_MODULE_0__[\"cursor\"].y, 20, 20)\r\n  visCtx.fillText(focus1.x + \" \" + focus1.y, 20, 40)\r\n  visCtx.fillText(focus1.innerAngle, 20, 60)\r\n\r\n  if (ghostShape) {\r\n    ghostShape.draw(visCtx, 1, true);\r\n  }\r\n\r\n  drawPath(visCtx)\r\n\r\n  requestAnimationFrame(tick);\r\n}\r\n\r\nlet theta = 0;\r\nlet ghostShape = null;\r\nlet focus1 = {};\r\n\r\nfunction update() {\r\n  let pt = closest();\r\n  if (!pt) return;\r\n\r\n  focus1 = pt;\r\n  let shapeClass = _cursor_js__WEBPACK_IMPORTED_MODULE_0__[\"chosenShape\"] == _globals__WEBPACK_IMPORTED_MODULE_2__[\"Shapes\"].KITE ? _shapes_js__WEBPACK_IMPORTED_MODULE_3__[\"Kite\"] : _shapes_js__WEBPACK_IMPORTED_MODULE_3__[\"Dart\"];\r\n  let turn = shapeClass.rotationForFit(pt.alpha, pt.blue);\r\n  theta = pt.theta + turn;\r\n  theta = Object(_globals__WEBPACK_IMPORTED_MODULE_2__[\"posMod\"])(theta, 360);\r\n\r\n\r\n  let c = Math.cos(Object(_globals__WEBPACK_IMPORTED_MODULE_2__[\"degrees2Radians\"])(theta));\r\n  let s = Math.sin(Object(_globals__WEBPACK_IMPORTED_MODULE_2__[\"degrees2Radians\"])(theta));\r\n  let t = shapeClass.translationForFit(focus1.alpha, focus1.blue);\r\n  let x = t[0] * c - t[1] * s;\r\n  let y = t[0] * s + t[1] * c;\r\n\r\n  ghostShape = new shapeClass(focus1.x + x, focus1.y + y, theta);\r\n    \r\n\r\n}\r\n\r\nfunction closest() {\r\n  let res = _globals__WEBPACK_IMPORTED_MODULE_2__[\"tree\"].nearest(_cursor_js__WEBPACK_IMPORTED_MODULE_0__[\"cursor\"], 2);\r\n  let nearest1 = res[0];\r\n  let nearest2 = res[1];\r\n  let [pt1] = nearest1 || [];\r\n  if (!pt1) return null;\r\n  let [pt2] = nearest2 || [];\r\n  \r\n  if (!pt2) pt2 = {};\r\n\r\n  let d1 = Object(_globals__WEBPACK_IMPORTED_MODULE_2__[\"dist\"])(_cursor_js__WEBPACK_IMPORTED_MODULE_0__[\"cursor\"], Object(_globals__WEBPACK_IMPORTED_MODULE_2__[\"midpoint\"])(pt1, pt1.next));\r\n  let d2 = Object(_globals__WEBPACK_IMPORTED_MODULE_2__[\"dist\"])(_cursor_js__WEBPACK_IMPORTED_MODULE_0__[\"cursor\"], Object(_globals__WEBPACK_IMPORTED_MODULE_2__[\"midpoint\"])(pt1, pt1.prev));\r\n  let d3 = Object(_globals__WEBPACK_IMPORTED_MODULE_2__[\"dist\"])(_cursor_js__WEBPACK_IMPORTED_MODULE_0__[\"cursor\"], Object(_globals__WEBPACK_IMPORTED_MODULE_2__[\"midpoint\"])(pt2, pt2.next));\r\n  let d4 = Object(_globals__WEBPACK_IMPORTED_MODULE_2__[\"dist\"])(_cursor_js__WEBPACK_IMPORTED_MODULE_0__[\"cursor\"], Object(_globals__WEBPACK_IMPORTED_MODULE_2__[\"midpoint\"])(pt2, pt2.prev));\r\n  \r\n  let d = Math.min(d1, d2, d3, d4);\r\n\r\n  if (d1 == d) return pt1;\r\n  if (d2 == d) return pt1.prev;\r\n  if (d3 == d) return pt2;\r\n  if (d4 == d) return pt1.prev;\r\n}\r\n\r\nfunction connect(a, b) {\r\n  a.next = b;\r\n  b.prev = a;\r\n}\r\n\r\n_globals__WEBPACK_IMPORTED_MODULE_2__[\"canvas\"].addEventListener(\"mousedown\", () => {\r\n  let pts = ghostShape.getPointsCopy();\r\n  \r\n  for (let pt of pts) {\r\n    let [existingPt] = _globals__WEBPACK_IMPORTED_MODULE_2__[\"tree\"].nearest(pt, 1)[0];\r\n    if (!Object(_globals__WEBPACK_IMPORTED_MODULE_2__[\"near\"])(pt, existingPt)) {\r\n      _globals__WEBPACK_IMPORTED_MODULE_2__[\"tree\"].insert(pt);\r\n      continue;\r\n    }\r\n\r\n    existingPt.innerAngle += pt.innerAngle;\r\n    let right = Object(_globals__WEBPACK_IMPORTED_MODULE_2__[\"near\"])(existingPt.next, pt.prev);\r\n    let left =  Object(_globals__WEBPACK_IMPORTED_MODULE_2__[\"near\"])(existingPt.prev, pt.next);\r\n\r\n    if (right) {\r\n      connect(existingPt, pt.next);\r\n      existingPt.alpha = pt.alpha;\r\n      existingPt.blue = pt.blue;\r\n      existingPt.theta = pt.theta;\r\n\r\n      console.log(\"right\")\r\n    }\r\n    if (left) {\r\n      connect(pt.prev, existingPt);\r\n      pt.prev.alpha = existingPt.prev.alpha\r\n      pt.prev.blue = existingPt.prev.blue\r\n      pt.prev.theta = existingPt.prev.theta\r\n\r\n      console.log(\"left\")\r\n    }\r\n\r\n    if (left && right && existingPt.innerAngle == 360) {\r\n      _globals__WEBPACK_IMPORTED_MODULE_2__[\"tree\"].remove(existingPt);\r\n    }\r\n  }\r\n});\r\n\r\n\r\nwindow.addEventListener(\"keypress\", e => {\r\n  if      (e.key == \"q\") theta -= 18;\r\n  else if (e.key == \"e\") theta += 18;\r\n  else if (e.key == \"1\") chosenShape = _globals__WEBPACK_IMPORTED_MODULE_2__[\"Shapes\"].KITE;\r\n  else if (e.key == \"2\") chosenShape = _globals__WEBPACK_IMPORTED_MODULE_2__[\"Shapes\"].DART;\r\n  theta = Object(_globals__WEBPACK_IMPORTED_MODULE_2__[\"posMod\"])(theta, 360);\r\n});\r\n\r\n\n\n//# sourceURL=webpack:///./src/main.js?");

/***/ }),

/***/ "./src/shapes.js":
/*!***********************!*\
  !*** ./src/shapes.js ***!
  \***********************/
/*! exports provided: Kite, Dart */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Kite\", function() { return Kite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Dart\", function() { return Dart; });\n/* harmony import */ var _vertices__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vertices */ \"./src/vertices.js\");\n/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./globals */ \"./src/globals.js\");\n\r\n\r\n\r\nfunction drawVertices(ctx, vertices) {\r\n  ctx.moveTo(vertices[0], vertices[1]);\r\n  ctx.lineTo(vertices[2], vertices[3]);\r\n  ctx.lineTo(vertices[4], vertices[5]);\r\n  ctx.lineTo(vertices[6], vertices[7]);\r\n  ctx.fill();\r\n}\r\n\r\nconst BLUE = true;\r\nconst RED = false;\r\n\r\nclass Kite {\r\n  constructor(x, y, theta=0) {\r\n    this.x = x || 0;\r\n    this.y = y || 0;\r\n    this.verts = Object(_vertices__WEBPACK_IMPORTED_MODULE_0__[\"getVertices\"])(theta, _globals__WEBPACK_IMPORTED_MODULE_1__[\"Shapes\"].KITE);\r\n\r\n    this.theta = Object(_globals__WEBPACK_IMPORTED_MODULE_1__[\"posMod\"])(theta, 360);\r\n\r\n    let bottom = new PointNode(x + this.verts[0], y + this.verts[1], 72, 234 + theta, true, BLUE);\r\n    let left   = new PointNode(x + this.verts[2], y + this.verts[3], 72, 342 + theta, false, RED);\r\n    let top    = new PointNode(x + this.verts[4], y + this.verts[5], 144, 18 + theta, true, RED);\r\n    let right  = new PointNode(x + this.verts[6], y + this.verts[7], 72, 126 + theta, false, BLUE);\r\n    bottom.shapeNext = left; bottom.next = left; bottom.prev = right;\r\n    left.shapeNext = top; left.next = top; left.prev = bottom;\r\n    top.shapeNext = right; top.next = right; top.prev = left;\r\n    right.shapeNext = bottom; right.next = bottom; right.prev = top;\r\n\r\n    this.pts = [bottom, left, top, right];\r\n  }\r\n\r\n  get alphas() {\r\n    return [this.pts[0], this.pts[2]];\r\n  }\r\n\r\n  get betas() {\r\n    return [this.pts[1], this.pts[3]];\r\n  }\r\n\r\n  getPointsCopy() {\r\n    return [...this.pts];\r\n  }\r\n\r\n  static translationForFit(alpha, blue) {\r\n    if (alpha && blue) return [0, -100];\r\n    if (alpha && !blue) return [0, 0];\r\n    if (!alpha && blue) return [_globals__WEBPACK_IMPORTED_MODULE_1__[\"SIN36\"] * 100, (_globals__WEBPACK_IMPORTED_MODULE_1__[\"COS36\"] - 1)*100];\r\n    if (!alpha && !blue) return [-_globals__WEBPACK_IMPORTED_MODULE_1__[\"SIN36\"] * 100, (_globals__WEBPACK_IMPORTED_MODULE_1__[\"COS36\"] - 1)*100];\r\n  }\r\n\r\n  static rotationForFit(alpha, blue) {\r\n    if (alpha && blue) return 54;\r\n    if (alpha && !blue) return 198;\r\n    if (!alpha && blue) return 306;\r\n    if (!alpha && !blue) return 162;\r\n  }\r\n\r\n  draw(ctx, scale=1, stroke=false) {\r\n    let {x, y} = this;\r\n    ctx.save();\r\n    ctx.translate(x, y);\r\n    ctx.rotate(Object(_globals__WEBPACK_IMPORTED_MODULE_1__[\"degrees2Radians\"])(this.theta));\r\n    ctx.scale(scale, scale);\r\n\r\n    ctx.beginPath();\r\n    ctx.fillStyle = \"lime\";\r\n    drawVertices(ctx, _vertices__WEBPACK_IMPORTED_MODULE_0__[\"kiteVertices\"][0]);\r\n    if (stroke) ctx.stroke();\r\n\r\n    ctx.lineWidth = 5/scale;\r\n    ctx.beginPath();\r\n    ctx.strokeStyle=\"red\";\r\n    ctx.arc(0, 0, (1-0.61803) * 100, .1*_globals__WEBPACK_IMPORTED_MODULE_1__[\"PI\"], .9*_globals__WEBPACK_IMPORTED_MODULE_1__[\"PI\"]);\r\n    ctx.stroke();\r\n\r\n    ctx.beginPath();\r\n    ctx.strokeStyle=\"blue\";\r\n    ctx.arc(0, 1 * 100, (0.61803) * 100, -.7*_globals__WEBPACK_IMPORTED_MODULE_1__[\"PI\"], -.3*_globals__WEBPACK_IMPORTED_MODULE_1__[\"PI\"]);\r\n    ctx.stroke();\r\n\r\n    ctx.restore();\r\n  }\r\n}\r\n\r\nclass Dart {\r\n  constructor(x, y, theta=0) {\r\n    this.x = x || 0;\r\n    this.y = y || 0;\r\n    \r\n    this.theta = Object(_globals__WEBPACK_IMPORTED_MODULE_1__[\"posMod\"])(theta, 360);\r\n\r\n    this.verts = Object(_vertices__WEBPACK_IMPORTED_MODULE_0__[\"getVertices\"])(theta, _globals__WEBPACK_IMPORTED_MODULE_1__[\"Shapes\"].DART);\r\n\r\n    let bottom = new PointNode(x + this.verts[0], y + this.verts[1], 216, 162 + theta, false, RED);\r\n    let left   = new PointNode(x + this.verts[2], y + this.verts[3], 36, 306 + theta, true, BLUE);\r\n    let top    = new PointNode(x + this.verts[4], y + this.verts[5], 72, 54 + theta, false, BLUE);\r\n    let right  = new PointNode(x + this.verts[6], y + this.verts[7], 36, 198 + theta, true, RED);\r\n    bottom.shapeNext = left; bottom.next = left; bottom.prev = right;\r\n    left.shapeNext = top; left.next = top; left.prev = bottom;\r\n    top.shapeNext = right; top.next = right; top.prev = left;\r\n    right.shapeNext = bottom; right.next = bottom; right.prev = top;\r\n\r\n    this.pts = [bottom, left, top, right];\r\n  }\r\n\r\n  get alphas() {\r\n    return [this.pts[1], this.pts[3]];\r\n  }\r\n  \r\n  get betas() {\r\n    return [this.pts[0], this.pts[2]];\r\n  }\r\n\r\n  getPointsCopy() {\r\n    return [...this.pts];\r\n  }\r\n\r\n  static translationForFit(alpha, blue) {\r\n    if (alpha && blue) return [-_globals__WEBPACK_IMPORTED_MODULE_1__[\"SIN36\"] * 100, (_globals__WEBPACK_IMPORTED_MODULE_1__[\"COS36\"]-1) * 100];\r\n    if (alpha && !blue) return [_globals__WEBPACK_IMPORTED_MODULE_1__[\"SIN36\"] * 100, (_globals__WEBPACK_IMPORTED_MODULE_1__[\"COS36\"]-1) * 100];\r\n    if (!alpha && blue) return [0, (_globals__WEBPACK_IMPORTED_MODULE_1__[\"PHI\"]-1) * 100];\r\n    if (!alpha && !blue) return [0, 0];\r\n  }\r\n\r\n  static rotationForFit(alpha, blue) {\r\n    if (alpha && blue) return 126;\r\n    if (alpha && !blue) return 18;\r\n    if (!alpha && blue) return 234;\r\n    if (!alpha && !blue) return 342;\r\n  }\r\n\r\n  draw(ctx, scale=1, stroke=false) {\r\n    let {x, y} = this;\r\n    ctx.save();\r\n    ctx.translate(x, y);\r\n    ctx.rotate(Object(_globals__WEBPACK_IMPORTED_MODULE_1__[\"degrees2Radians\"])(this.theta));\r\n    ctx.scale(scale, scale);\r\n    \r\n    ctx.beginPath();\r\n    ctx.fillStyle = \"yellow\";\r\n    drawVertices(ctx, _vertices__WEBPACK_IMPORTED_MODULE_0__[\"dartVertices\"][0]);\r\n    if (stroke) ctx.stroke();\r\n\r\n    ctx.lineWidth = 5/scale;\r\n    ctx.beginPath();\r\n    ctx.strokeStyle=\"red\";\r\n    ctx.arc(0, 0, (1-0.61803)*0.61803 * 100, .9*_globals__WEBPACK_IMPORTED_MODULE_1__[\"PI\"], 2.1*_globals__WEBPACK_IMPORTED_MODULE_1__[\"PI\"]);\r\n    ctx.stroke();\r\n\r\n    ctx.beginPath();\r\n    ctx.strokeStyle=\"blue\";\r\n    ctx.arc(0, -0.61803 * 100, (1-0.61803) * 100, .3*_globals__WEBPACK_IMPORTED_MODULE_1__[\"PI\"], .7*_globals__WEBPACK_IMPORTED_MODULE_1__[\"PI\"]);\r\n    ctx.stroke();\r\n\r\n    ctx.restore();\r\n  }\r\n}\r\n\r\nclass PointNode {\r\n  constructor(x, y, innerAngle, theta, alpha, blue) {\r\n    this.x = x;\r\n    this.y = y;\r\n    \r\n    this.innerAngle = innerAngle;\r\n\r\n    this.next = null;\r\n    this.prev = null;\r\n\r\n    this.theta = Object(_globals__WEBPACK_IMPORTED_MODULE_1__[\"posMod\"])(theta, 360);\r\n    this.blue = blue;\r\n\r\n    this.alpha = alpha;\r\n    this.shapeNext;\r\n  }\r\n  get beta() { return !this.alpha}\r\n  get red() { return !this.blue}\r\n}\n\n//# sourceURL=webpack:///./src/shapes.js?");

/***/ }),

/***/ "./src/vertices.js":
/*!*************************!*\
  !*** ./src/vertices.js ***!
  \*************************/
/*! exports provided: kiteVertices, dartVertices, getVertices */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"kiteVertices\", function() { return kiteVertices; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dartVertices\", function() { return dartVertices; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getVertices\", function() { return getVertices; });\n/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals */ \"./src/globals.js\");\n\r\n\r\nconst k = [\r\n  0, 1,\r\n  -_globals__WEBPACK_IMPORTED_MODULE_0__[\"SIN36\"], 1 - _globals__WEBPACK_IMPORTED_MODULE_0__[\"COS36\"],\r\n  0, 0,\r\n  _globals__WEBPACK_IMPORTED_MODULE_0__[\"SIN36\"], 1 - _globals__WEBPACK_IMPORTED_MODULE_0__[\"COS36\"],\r\n].map(x => x * 100);\r\n\r\nconst d = [\r\n  0, 0,\r\n  -_globals__WEBPACK_IMPORTED_MODULE_0__[\"SIN36\"], 1 - _globals__WEBPACK_IMPORTED_MODULE_0__[\"COS36\"],\r\n  0, 1 - _globals__WEBPACK_IMPORTED_MODULE_0__[\"PHI\"],\r\n  _globals__WEBPACK_IMPORTED_MODULE_0__[\"SIN36\"], 1 - _globals__WEBPACK_IMPORTED_MODULE_0__[\"COS36\"],\r\n].map(x => x * 100);\r\n\r\nconst pi = Math.PI;\r\nconst kiteVertices = {\r\n  \"0\": rotateVertices(k, 0),\r\n  \"36\": rotateVertices(k, pi/5),\r\n  \"72\": rotateVertices(k, 2*pi/5),\r\n  \"108\": rotateVertices(k, 3*pi/5),\r\n  \"144\": rotateVertices(k, 4*pi/5),\r\n  \"180\": rotateVertices(k, 5*pi/5),\r\n  \"216\": rotateVertices(k, 6*pi/5),\r\n  \"252\": rotateVertices(k, 7*pi/5),\r\n  \"288\": rotateVertices(k, 8*pi/5),\r\n  \"324\": rotateVertices(k, 9*pi/5),\r\n}\r\n\r\nconst dartVertices = {\r\n  \"0\": rotateVertices(d, 0),\r\n  \"36\": rotateVertices(d, pi/5),\r\n  \"72\": rotateVertices(d, 2*pi/5),\r\n  \"108\": rotateVertices(d, 3*pi/5),\r\n  \"144\": rotateVertices(d, 4*pi/5),\r\n  \"180\": rotateVertices(d, 5*pi/5),\r\n  \"216\": rotateVertices(d, 6*pi/5),\r\n  \"252\": rotateVertices(d, 7*pi/5),\r\n  \"288\": rotateVertices(d, 8*pi/5),\r\n  \"324\": rotateVertices(d, 9*pi/5),\r\n}\r\n\r\n\r\nfunction getVertices(angle, shapeType) {\r\n  let seg = Math.round((angle) / 36) % 10;\r\n  seg = Object(_globals__WEBPACK_IMPORTED_MODULE_0__[\"posMod\"])(seg, 10);\r\n  let key = seg * 36;\r\n  if (shapeType == _globals__WEBPACK_IMPORTED_MODULE_0__[\"Shapes\"].KITE) {\r\n    return kiteVertices[key]\r\n  }\r\n  return dartVertices[key];\r\n}\r\n\r\n\r\nfunction rotateVertices(vertices, angle) {\r\n  let s = Math.sin(angle);\r\n  let c = Math.cos(angle);\r\n  let newV = [];\r\n  for (let i = 0; i < vertices.length; i += 2) {\r\n    let xnew = vertices[i] * c - vertices[i + 1] * s;\r\n    let ynew = vertices[i] * s + vertices[i + 1] * c;\r\n    newV.push(xnew)\r\n    newV.push(ynew)\r\n  }\r\n  return newV;\r\n}\r\n\n\n//# sourceURL=webpack:///./src/vertices.js?");

/***/ })

/******/ });